(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["PolyjuiceHttpProvider"] = factory();
	else
		root["PolyjuiceHttpProvider"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 923:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Abi = void 0;
const Web3EthAbi = __webpack_require__(107);
class Abi {
    constructor(_abi_items) {
        this.abi_items = [];
        this.interested_methods = [];
        this.interested_method_ids = {};
        this.abi_items = _abi_items;
        this.interested_methods = this.filter_interested_methods(this.abi_items);
        this.interested_method_ids = this.get_method_ids(this.interested_methods);
    }
    get_method_ids(_abi_items) {
        const method_ids = {};
        for (let item of _abi_items) {
            const id = Web3EthAbi.encodeFunctionSignature(item).slice(2);
            method_ids[id] = item;
        }
        return method_ids;
    }
    filter_interested_methods(_abi_items) {
        return _abi_items.filter((item) => item.type === "function" &&
            (this.filter_interested_inputs(item).length > 0 || // at least one param is eth-address
                this.filter_interested_outputs(item).length > 0) // at least one output return type is eth-address
        );
    }
    filter_interested_inputs(_abiItem) {
        return _abiItem.inputs.filter((input) => input.type === "address" || input.type === "address[]");
    }
    filter_interested_outputs(_abiItem) {
        return _abiItem.outputs.filter((output) => output.type === "address" || output.type === "address[]");
    }
    get_interested_methods() {
        return this.interested_methods;
    }
    get_abi_items() {
        return this.abi_items;
    }
    decode_method(data) {
        const method_id = data.slice(2, 10);
        const abiItem = this.interested_method_ids[method_id];
        if (abiItem) {
            let decoded = Web3EthAbi.decodeParameters(abiItem.inputs, "0x" + data.slice(10));
            let retData = {
                name: abiItem.name,
                params: [],
            };
            for (let i = 0; i < decoded.__length__; i++) {
                let param = decoded[i];
                let parsedParam = param;
                const isUint = abiItem.inputs[i].type.indexOf("uint") === 0;
                const isInt = abiItem.inputs[i].type.indexOf("int") === 0;
                const isAddress = abiItem.inputs[i].type.indexOf("address") === 0;
                if (isUint || isInt) {
                    const isArray = Array.isArray(param);
                    if (isArray) {
                        parsedParam = param.map((val) => BigInt(val).toString());
                    }
                    else {
                        parsedParam = BigInt(param).toString();
                    }
                }
                // Addresses returned by web3 are randomly cased so we need to standardize and lowercase all
                if (isAddress) {
                    const isArray = Array.isArray(param);
                    if (isArray) {
                        parsedParam = param.map((_) => _.toLowerCase());
                    }
                    else {
                        parsedParam = param.toLowerCase();
                    }
                }
                retData.params.push({
                    name: abiItem.inputs[i].name,
                    value: parsedParam,
                    type: abiItem.inputs[i].type,
                });
            }
            return retData;
        }
    }
    // todo: use this func to remove all repeated code.
    // params: <data: eth tx's encode input data>
    get_intereted_abi_item_by_encoded_data(data) {
        const method_id = data.slice(2, 10);
        const abi_item = this.interested_method_ids[method_id];
        return abi_item;
    }
    // decode method data, if it is related with address type in inputs,
    // replace the address params with godwoken_short_address
    async refactor_data_with_short_address(data, calculate_short_address) {
        const method_id = data.slice(2, 10);
        const abi_item = this.interested_method_ids[method_id];
        if (!abi_item)
            return data;
        const decode_data = this.decode_method(data);
        const new_decode_data = decode_data.params.map(async (p) => {
            if (p.type === "address" || p.type === "address[]") {
                p.value = Array.isArray(p.value)
                    ? await Promise.all(p.value.map(async (v) => await calculate_short_address(v)))
                    : await calculate_short_address(p.value);
                return p;
            }
            else {
                return p;
            }
        });
        const new_data = Web3EthAbi.encodeFunctionCall(abi_item, await Promise.all(new_decode_data.map(async (p) => (await p).value)));
        return new_data;
    }
    // decode the run_result return value, and check:
    // 	if it is related with address type, replace godwoken_short_address with eth_address.
    //
    // known-issue:
    // 	- when the return value is EOA address and when it haven't create account on godowken,
    //	  then we have no idea what the original eth_address is. we are not able to recover original address.
    //	 thus we do not support return address type which is not exist here
    async refactor_return_value_with_short_address(return_value, abi_item, calculate_short_address) {
        const output_value_types = abi_item.outputs.map((item) => item.type);
        var decoded_values = Web3EthAbi.decodeParameters(output_value_types, return_value);
        const interested_value_indexs = output_value_types.map((t, index) => {
            if (t === "address" || t === "address[]") {
                return index;
            }
        });
        for await (const index of interested_value_indexs) {
            decoded_values[index + ""] = Array.isArray(decoded_values[index + ""])
                ? await Promise.all(decoded_values[index + ""].map(async (v) => await calculate_short_address(v)))
                : await calculate_short_address(decoded_values[index + ""]);
        }
        let decode_values_with_refactor = Object.values(decoded_values);
        decode_values_with_refactor = decode_values_with_refactor.slice(0, decode_values_with_refactor.length - 1);
        return Web3EthAbi.encodeParameters(output_value_types, decode_values_with_refactor);
    }
    // todo: support user providing an url path, and read the abi json from it
    read_abi_from_json_file() { }
}
exports.Abi = Abi;


/***/ }),

/***/ 971:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * this file is a custom http provider used to proxy ETH rpc call to godwoken-polyjuice chain.
 * it is fork and based on https://github.com/ChainSafe/web3.js/tree/1.x/packages/web3-providers-http
 * this is only aims for nodejs development popurse. it will sign tx with private-key, which it is dangerours.
 * please ues it at your own risk.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const signer_1 = __importDefault(__webpack_require__(957));
const index_1 = __importDefault(__webpack_require__(303));
class PolyjuiceHttpProviderForNode extends index_1.default {
    constructor(host, godwoken_config, abi_items = [], private_key, options) {
        super(host, godwoken_config, abi_items);
        this.signer = new signer_1.default(private_key);
    }
    async send(payload, callback) {
        const { method, params } = payload;
        switch (method) {
            case "eth_sendTransaction":
                try {
                    const { from, gas, gasPrice, value, data } = params[0];
                    const to = params[0].to || `0x${Array(40).fill(0).join("")}`;
                    const data_with_short_address = await this.abi.refactor_data_with_short_address(data, this.godwoker.getShortAddressByAllTypeEthAddress.bind(this.godwoker));
                    const t = {
                        from: from,
                        to: to,
                        value: value || 0,
                        data: data_with_short_address || "",
                        gas: gas,
                        gasPrice: gasPrice,
                    };
                    const to_id = await this.godwoker.allTypeEthAddressToAccountId(to);
                    const sender_script_hash = this.godwoker.computeScriptHashByEoaEthAddress(from);
                    const receiver_script_hash = await this.godwoker.getScriptHashByAccountId(parseInt(to_id));
                    const polyjuice_tx = await this.godwoker.assembleRawL2Transaction(t);
                    // ready to sign tx
                    console.log(`it is very dangerous to sign with private-key, please use it carefully and only use in test development!`);
                    const message = this.godwoker.generateTransactionMessageToSign(polyjuice_tx, sender_script_hash, receiver_script_hash);
                    const _signature = await this.signer.sign_with_private_key(message, from);
                    const signature = this.godwoker.packSignature(_signature);
                    const tx_hash = await this.godwoker.gw_submitL2Transaction(polyjuice_tx, signature);
                    await this.godwoker.waitForTransactionReceipt(tx_hash);
                    this._send(payload, function (err, result) {
                        const res = {
                            jsonrpc: result.jsonrpc,
                            id: result.id,
                        };
                        const new_res = { ...res, ...{ result: tx_hash } };
                        callback(null, new_res);
                    });
                    break;
                }
                catch (error) {
                    this.connected = false;
                    throw error;
                }
            default:
                try {
                    super.send(payload, callback);
                    break;
                }
                catch (error) {
                    this.connected = false;
                    throw error;
                }
        }
    }
}
exports.default = PolyjuiceHttpProviderForNode;


/***/ }),

/***/ 445:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(293)["Buffer"];
const { RPC, Reader } = __webpack_require__(683);
const { utils } = __webpack_require__(916);
const keccak256 = __webpack_require__(715);
const { NormalizeL2Transaction, NormalizeRawL2Transaction, NormalizeCreateAccount, NormalizeWithdrawalRequest, NormalizeRawWithdrawalRequest, } = __webpack_require__(197);
const normalizer = __webpack_require__(197);
const core = __webpack_require__(243);
function numberToUInt32LE(value) {
    const buf = Buffer.alloc(4);
    buf.writeUInt32LE(value);
    return `0x${buf.toString("hex")}`;
}
function UInt32LEToNumber(hex) {
    const buf = Buffer.from(hex.slice(2, 10), "hex");
    return buf.readUInt32LE(0);
}
function u32ToHex(value) {
    return `0x${value.toString(16)}`;
}
function hexToU32(hex) {
    return parseInt(hex.slice(2), "hex");
}
function toBuffer(ab) {
    var buf = Buffer.alloc(ab.byteLength);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buf.length; ++i) {
        buf[i] = view[i];
    }
    return buf;
}
function toArrayBuffer(buf) {
    var ab = new ArrayBuffer(buf.length);
    var view = new Uint8Array(ab);
    for (var i = 0; i < buf.length; ++i) {
        view[i] = buf[i];
    }
    return ab;
}
class Godwoken {
    constructor(url) {
        this.rpc = new RPC(url);
        this.utils = new GodwokenUtils();
    }
    async _send(l2tx, method) {
        const data = new Reader(core.SerializeL2Transaction(NormalizeL2Transaction(l2tx))).serializeJson();
        return await method(data);
    }
    async ping() {
        return await this.rpc.ping();
    }
    async getTipBlockHash() {
        return await this.rpc.get_tip_block_hash();
    }
    async getBlockHash(block_number) {
        return await this.rpc.get_block_hash(block_number);
    }
    async getBlock(block_hash) {
        return await this.rpc.get_block(block_hash);
    }
    async getBlockByNumber(block_number) {
        return await this.rpc.get_block_by_number(block_number);
    }
    async executeL2Transaction(l2tx) {
        return this._send(l2tx, this.rpc.execute_l2transaction);
    }
    async submitL2Transaction(l2tx) {
        return this._send(l2tx, this.rpc.submit_l2transaction);
    }
    async submitWithdrawalRequest(request) {
        const data = new Reader(core.SerializeWithdrawalRequest(NormalizeWithdrawalRequest(request))).serializeJson();
        return await this.rpc.submit_withdrawal_request(data);
    }
    async getBalance(sudt_id, account_id) {
        // TODO: maybe swap params later?
        console.log("0x" + account_id.toString(16), "0x" + sudt_id.toString(16));
        const hex = await this.rpc.get_balance("0x" + account_id.toString(16), "0x" + sudt_id.toString(16));
        return BigInt(hex);
    }
    async getStorageAt(account_id, key) {
        return await this.rpc.get_storage_at(account_id, key);
    }
    async getAccountIdByScriptHash(script_hash) {
        return await this.rpc.get_account_id_by_script_hash(script_hash);
    }
    async getNonce(account_id) {
        console.log(account_id.toString(16));
        return await this.rpc.get_nonce("0x" + account_id.toString(16));
    }
    async getScript(script_hash) {
        return await this.rpc.get_script(script_hash);
    }
    async getScriptHash(account_id) {
        return await this.rpc.get_script_hash("0x" + account_id.toString(16));
    }
    async getData(data_hash) {
        return await this.rpc.get_data(data_hash);
    }
}
class GodwokenUtils {
    constructor(rollup_type_hash) {
        this.rollup_type_hash = rollup_type_hash;
    }
    generateTransactionMessageToSign(raw_l2tx, _sender_scirpt_hash, _receiver_script_hash, add_prefix = true) {
        const raw_tx_data = core.SerializeRawL2Transaction(NormalizeRawL2Transaction(raw_l2tx));
        const rollup_type_hash = Buffer.from(this.rollup_type_hash.slice(2), "hex");
        const sender_scirpt_hash = Buffer.from(_sender_scirpt_hash.slice(2), "hex");
        const receiver_script_hash = Buffer.from(_receiver_script_hash.slice(2), "hex");
        const data = toArrayBuffer(Buffer.concat([
            rollup_type_hash,
            sender_scirpt_hash,
            receiver_script_hash,
            toBuffer(raw_tx_data),
        ]));
        const message = utils.ckbHash(data).serializeJson();
        if (add_prefix === false) {
            // do not add `\x19Ethereum Signed Message:\n32` prefix when generating message
            // set true when you want to pass message for metamask signing,
            // metamask will add this automattically.
            return message;
        }
        const prefix_buf = Buffer.from(`\x19Ethereum Signed Message:\n32`);
        const buf = Buffer.concat([
            prefix_buf,
            Buffer.from(message.slice(2), "hex"),
        ]);
        return `0x${keccak256(buf).toString("hex")}`;
    }
    generateWithdrawalMessageToSign(raw_request) {
        const raw_request_data = core.SerializeRawWithdrawalRequest(NormalizeRawWithdrawalRequest(raw_request));
        const rollup_type_hash = Buffer.from(this.rollup_type_hash.slice(2), "hex");
        const data = toArrayBuffer(Buffer.concat([rollup_type_hash, toBuffer(raw_request_data)]));
        const message = utils.ckbHash(data).serializeJson();
        const prefix_buf = Buffer.from(`\x19Ethereum Signed Message:\n32`);
        const buf = Buffer.concat([
            prefix_buf,
            Buffer.from(message.slice(2), "hex"),
        ]);
        return `0x${keccak256(buf).toString("hex")}`;
    }
    static createAccountRawL2Transaction(from_id, nonce, script) {
        const create_account = { script };
        const enum_tag = "0x00000000";
        const create_account_part = new Reader(core.SerializeCreateAccount(NormalizeCreateAccount(create_account))).serializeJson();
        const args = enum_tag + create_account_part.slice(2);
        return {
            from_id: u32ToHex(from_id),
            to_id: u32ToHex(0),
            nonce: u32ToHex(nonce),
            args,
        };
    }
    static createRawWithdrawalRequest(nonce, capacity, amount, sudt_script_hash, account_script_hash, sell_amount, sell_capacity, owner_lock_hash, payment_lock_hash) {
        return {
            nonce: "0x" + BigInt(nonce).toString(16),
            capacity: "0x" + BigInt(capacity).toString(16),
            amount: "0x" + BigInt(amount).toString(16),
            sudt_script_hash: sudt_script_hash,
            account_script_hash: account_script_hash,
            sell_amount: "0x" + BigInt(sell_amount).toString(16),
            sell_capacity: "0x" + BigInt(sell_capacity).toString(16),
            owner_lock_hash: owner_lock_hash,
            payment_lock_hash: payment_lock_hash,
        };
    }
}
module.exports = {
    Godwoken,
    GodwokenUtils,
    numberToUInt32LE,
    UInt32LEToNumber,
    u32ToHex,
    hexToU32,
    toBuffer,
    core,
    normalizer,
};


/***/ }),

/***/ 197:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NormalizeUnlockWithdrawalViaFinalize = exports.NormalizeWithdrawalLockArgs = exports.NormalizeSUDTTransfer = exports.NormalizeSUDTQuery = exports.NormalizeCreateAccount = exports.NormalizeWithdrawalRequest = exports.NormalizeRawWithdrawalRequest = exports.NormalizeL2Transaction = exports.NormalizeRawL2Transaction = exports.NormalizeCustodianLockArgs = exports.NormalizeHeaderInfo = exports.NormalizeDepositLockArgs = exports.NormalizeDepositRequest = void 0;
const ckb_js_toolkit_1 = __webpack_require__(683);
// Taken for now from https://github.com/xxuejie/ckb-js-toolkit/blob/68f5ff709f78eb188ee116b2887a362123b016cc/src/normalizers.js#L17-L69,
// later we can think about exposing those functions directly.
function normalizeHexNumber(length) {
    return function (debugPath, value) {
        if (!(value instanceof ArrayBuffer)) {
            let intValue = BigInt(value).toString(16);
            if (intValue.length % 2 !== 0) {
                intValue = "0" + intValue;
            }
            if (intValue.length / 2 > length) {
                throw new Error(`${debugPath} is ${intValue.length / 2} bytes long, expected length is ${length}!`);
            }
            const view = new DataView(new ArrayBuffer(length));
            for (let i = 0; i < intValue.length / 2; i++) {
                const start = intValue.length - (i + 1) * 2;
                view.setUint8(i, parseInt(intValue.substr(start, 2), 16));
            }
            value = view.buffer;
        }
        if (value.byteLength < length) {
            const array = new Uint8Array(length);
            array.set(new Uint8Array(value), 0);
            value = array.buffer;
        }
        return value;
    };
}
function normalizeRawData(length) {
    return function (debugPath, value) {
        value = new ckb_js_toolkit_1.Reader(value).toArrayBuffer();
        if (length > 0 && value.byteLength !== length) {
            throw new Error(`${debugPath} has invalid length ${value.byteLength}, required: ${length}`);
        }
        return value;
    };
}
function normalizeObject(debugPath, obj, keys) {
    const result = {};
    for (const [key, f] of Object.entries(keys)) {
        const value = obj[key];
        if (!value) {
            throw new Error(`${debugPath} is missing ${key}!`);
        }
        result[key] = f(`${debugPath}.${key}`, value);
    }
    return result;
}
function toNormalize(normalize) {
    return function (debugPath, value) {
        return normalize(value, {
            debugPath,
        });
    };
}
function NormalizeDepositRequest(request, { debugPath = "deposit_request" } = {}) {
    return normalizeObject(debugPath, request, {
        capacity: normalizeHexNumber(8),
        amount: normalizeHexNumber(16),
        sudt_script_hash: normalizeRawData(32),
        script: toNormalize(ckb_js_toolkit_1.normalizers.NormalizeScript),
    });
}
exports.NormalizeDepositRequest = NormalizeDepositRequest;
function NormalizeDepositLockArgs(args, { debugPath = "deposit_lock_args" } = {}) {
    return normalizeObject(debugPath, args, {
        owner_lock_hash: normalizeRawData(32),
        layer2_lock: toNormalize(ckb_js_toolkit_1.normalizers.NormalizeScript),
        cancel_timeout: normalizeHexNumber(8),
    });
}
exports.NormalizeDepositLockArgs = NormalizeDepositLockArgs;
function NormalizeHeaderInfo(headerInfo, { debugPath = "header_info" } = {}) {
    return normalizeObject(debugPath, headerInfo, {
        number: normalizeHexNumber(8),
        block_hash: normalizeRawData(32),
    });
}
exports.NormalizeHeaderInfo = NormalizeHeaderInfo;
function NormalizeCustodianLockArgs(args, { debugPath = "custondian_lock_args" } = {}) {
    return normalizeObject(debugPath, args, {
        owner_lock_hash: normalizeRawData(32),
        deposit_block_hash: normalizeRawData(32),
        deposit_block_number: normalizeHexNumber(8),
    });
}
exports.NormalizeCustodianLockArgs = NormalizeCustodianLockArgs;
function NormalizeRawL2Transaction(rawL2Transaction, { debugPath = "raw_l2_transaction" } = {}) {
    return normalizeObject(debugPath, rawL2Transaction, {
        from_id: normalizeHexNumber(4),
        to_id: normalizeHexNumber(4),
        nonce: normalizeHexNumber(4),
        args: normalizeRawData(-1),
    });
}
exports.NormalizeRawL2Transaction = NormalizeRawL2Transaction;
function NormalizeL2Transaction(l2Transaction, { debugPath = "l2_transaction" } = {}) {
    return normalizeObject(debugPath, l2Transaction, {
        raw: toNormalize(NormalizeRawL2Transaction),
        signature: normalizeRawData(65),
    });
}
exports.NormalizeL2Transaction = NormalizeL2Transaction;
function NormalizeRawWithdrawalRequest(raw_request, { debugPath = "raw_withdrawal_request" } = {}) {
    return normalizeObject(debugPath, raw_request, {
        nonce: normalizeHexNumber(4),
        capacity: normalizeHexNumber(8),
        amount: normalizeHexNumber(16),
        sudt_script_hash: normalizeRawData(32),
        account_script_hash: normalizeRawData(32),
        sell_amount: normalizeHexNumber(16),
        sell_capacity: normalizeHexNumber(8),
        owner_lock_hash: normalizeRawData(32),
        payment_lock_hash: normalizeRawData(32),
    });
}
exports.NormalizeRawWithdrawalRequest = NormalizeRawWithdrawalRequest;
function NormalizeWithdrawalRequest(request, { debugPath = "withdrawal_request" } = {}) {
    return normalizeObject(debugPath, request, {
        raw: toNormalize(NormalizeRawWithdrawalRequest),
        signature: normalizeRawData(65),
    });
}
exports.NormalizeWithdrawalRequest = NormalizeWithdrawalRequest;
function NormalizeCreateAccount(createAccount, { debugPath = "create_account" } = {}) {
    return normalizeObject(debugPath, createAccount, {
        script: toNormalize(ckb_js_toolkit_1.normalizers.NormalizeScript),
    });
}
exports.NormalizeCreateAccount = NormalizeCreateAccount;
function NormalizeSUDTQuery(sudt_query, { debugPath = "sudt_query" } = {}) {
    return normalizeObject(debugPath, sudt_query, {
        account_id: normalizeHexNumber(4),
    });
}
exports.NormalizeSUDTQuery = NormalizeSUDTQuery;
function NormalizeSUDTTransfer(sudt_transfer, { debugPath = "sudt_transfer" } = {}) {
    return normalizeObject(debugPath, sudt_transfer, {
        to: normalizeHexNumber(4),
        amount: normalizeHexNumber(16),
        fee: normalizeHexNumber(16),
    });
}
exports.NormalizeSUDTTransfer = NormalizeSUDTTransfer;
function NormalizeWithdrawalLockArgs(withdrawal_lock_args, { debugPath = "withdrawal_lock_args" } = {}) {
    return normalizeObject(debugPath, withdrawal_lock_args, {
        // the original deposit info
        // used for helping programs generate reverted custodian cell
        deposit_block_hash: normalizeRawData(32),
        deposit_block_number: normalizeHexNumber(8),
        // the original custodian lock hash
        withdrawal_block_hash: normalizeRawData(32),
        withdrawal_block_number: normalizeHexNumber(8),
        // buyer can pay sell_amount token to unlock
        sudt_script_hash: normalizeRawData(32),
        sell_amount: normalizeHexNumber(16),
        sell_capacity: normalizeHexNumber(8),
        // layer1 lock to withdraw after challenge period
        owner_lock_hash: normalizeRawData(32),
        // layer1 lock to receive the payment, must exists on the chain
        payment_lock_hash: normalizeRawData(32),
    });
}
exports.NormalizeWithdrawalLockArgs = NormalizeWithdrawalLockArgs;
function NormalizeUnlockWithdrawalViaFinalize(unlock_withdrawal_finalize, { debugPath = "unlock_withdrawal_finalize" } = {}) {
    return normalizeObject(debugPath, unlock_withdrawal_finalize, {
        block_proof: normalizeRawData(-1),
    });
}
exports.NormalizeUnlockWithdrawalViaFinalize = NormalizeUnlockWithdrawalViaFinalize;


/***/ }),

/***/ 243:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SerializeUnlockWithdrawalWitness = exports.UnlockWithdrawalWitness = exports.SerializeWithdrawalLockArgs = exports.WithdrawalLockArgs = exports.SerializeUnlockCustodianViaRevertWitness = exports.UnlockCustodianViaRevertWitness = exports.SerializeCustodianLockArgs = exports.CustodianLockArgs = exports.SerializeDepositLockArgs = exports.DepositLockArgs = exports.SerializeBlockInfo = exports.BlockInfo = exports.SerializeKVPairVec = exports.KVPairVec = exports.SerializeKVPair = exports.KVPair = exports.SerializeWithdrawalRequest = exports.WithdrawalRequest = exports.SerializeWithdrawalRequestVec = exports.WithdrawalRequestVec = exports.SerializeRawWithdrawalRequest = exports.RawWithdrawalRequest = exports.SerializeDepositRequestVec = exports.DepositRequestVec = exports.SerializeDepositRequest = exports.DepositRequest = exports.SerializeL2Block = exports.L2Block = exports.SerializeRawL2BlockVec = exports.RawL2BlockVec = exports.SerializeRawL2Block = exports.RawL2Block = exports.SerializeSubmitWithdrawals = exports.SubmitWithdrawals = exports.SerializeSubmitTransactions = exports.SubmitTransactions = exports.SerializeL2TransactionVec = exports.L2TransactionVec = exports.SerializeL2Transaction = exports.L2Transaction = exports.SerializeRawL2Transaction = exports.RawL2Transaction = exports.SerializeRollupConfig = exports.RollupConfig = exports.SerializeGlobalState = exports.GlobalState = exports.SerializeAccountMerkleState = exports.AccountMerkleState = exports.SerializeBlockMerkleState = exports.BlockMerkleState = void 0;
exports.SerializeRollupAction = exports.RollupAction = exports.SerializeRollupRevert = exports.RollupRevert = exports.SerializeRollupCancelChallenge = exports.RollupCancelChallenge = exports.SerializeRollupEnterChallenge = exports.RollupEnterChallenge = exports.SerializeRollupSubmitBlock = exports.RollupSubmitBlock = exports.SerializeVerifyWithdrawalWitness = exports.VerifyWithdrawalWitness = exports.SerializeVerifyTransactionSignatureWitness = exports.VerifyTransactionSignatureWitness = exports.SerializeVerifyTransactionSignatureContext = exports.VerifyTransactionSignatureContext = exports.SerializeVerifyTransactionWitness = exports.VerifyTransactionWitness = exports.SerializeVerifyTransactionContext = exports.VerifyTransactionContext = exports.SerializeBlockHashEntryVec = exports.BlockHashEntryVec = exports.SerializeBlockHashEntry = exports.BlockHashEntry = exports.SerializeScriptVec = exports.ScriptVec = exports.SerializeChallengeWitness = exports.ChallengeWitness = exports.SerializeChallengeLockArgs = exports.ChallengeLockArgs = exports.SerializeChallengeTarget = exports.ChallengeTarget = exports.SerializeSUDTTransfer = exports.SUDTTransfer = exports.SerializeSUDTQuery = exports.SUDTQuery = exports.SerializeSUDTArgs = exports.SUDTArgs = exports.SerializeCreateAccount = exports.CreateAccount = exports.SerializeMetaContractArgs = exports.MetaContractArgs = exports.SerializeStakeLockArgs = exports.StakeLockArgs = exports.SerializeUnlockWithdrawalViaTrade = exports.UnlockWithdrawalViaTrade = exports.SerializeUnlockWithdrawalViaRevert = exports.UnlockWithdrawalViaRevert = exports.SerializeUnlockWithdrawalViaFinalize = exports.UnlockWithdrawalViaFinalize = void 0;
exports.SerializeTransaction = exports.Transaction = exports.SerializeRawTransaction = exports.RawTransaction = exports.SerializeCellDep = exports.CellDep = exports.SerializeCellOutput = exports.CellOutput = exports.SerializeCellInput = exports.CellInput = exports.SerializeOutPoint = exports.OutPoint = exports.SerializeScript = exports.Script = exports.SerializeCellOutputVec = exports.CellOutputVec = exports.SerializeCellInputVec = exports.CellInputVec = exports.SerializeCellDepVec = exports.CellDepVec = exports.SerializeProposalShortIdVec = exports.ProposalShortIdVec = exports.SerializeTransactionVec = exports.TransactionVec = exports.SerializeUncleBlockVec = exports.UncleBlockVec = exports.SerializeProposalShortId = exports.ProposalShortId = exports.SerializeScriptOpt = exports.ScriptOpt = exports.SerializeByte32Vec = exports.Byte32Vec = exports.SerializeBytesVec = exports.BytesVec = exports.SerializeBytesOpt = exports.BytesOpt = exports.SerializeBytes = exports.Bytes = exports.SerializeUint256 = exports.Uint256 = exports.SerializeByte32 = exports.Byte32 = exports.SerializeUint128 = exports.Uint128 = exports.SerializeUint64 = exports.Uint64 = exports.SerializeUint32 = exports.Uint32 = exports.SerializeUint16 = exports.Uint16 = void 0;
exports.SerializeWitnessArgs = exports.WitnessArgs = exports.SerializeCellbaseWitness = exports.CellbaseWitness = exports.SerializeBlock = exports.Block = exports.SerializeUncleBlock = exports.UncleBlock = exports.SerializeHeader = exports.Header = exports.SerializeRawHeader = exports.RawHeader = void 0;
function dataLengthError(actual, required) {
    throw new Error(`Invalid data length! Required: ${required}, actual: ${actual}`);
}
function assertDataLength(actual, required) {
    if (actual !== required) {
        dataLengthError(actual, required);
    }
}
function assertArrayBuffer(reader) {
    if (reader instanceof Object && reader.toArrayBuffer instanceof Function) {
        reader = reader.toArrayBuffer();
    }
    if (!(reader instanceof ArrayBuffer)) {
        throw new Error("Provided value must be an ArrayBuffer or can be transformed into ArrayBuffer!");
    }
    return reader;
}
function verifyAndExtractOffsets(view, expectedFieldCount, compatible) {
    if (view.byteLength < 4) {
        dataLengthError(view.byteLength, ">4");
    }
    const requiredByteLength = view.getUint32(0, true);
    assertDataLength(view.byteLength, requiredByteLength);
    if (requiredByteLength === 4) {
        return [requiredByteLength];
    }
    if (requiredByteLength < 8) {
        dataLengthError(view.byteLength, ">8");
    }
    const firstOffset = view.getUint32(4, true);
    if (firstOffset % 4 !== 0 || firstOffset < 8) {
        throw new Error(`Invalid first offset: ${firstOffset}`);
    }
    const itemCount = firstOffset / 4 - 1;
    if (itemCount < expectedFieldCount) {
        throw new Error(`Item count not enough! Required: ${expectedFieldCount}, actual: ${itemCount}`);
    }
    else if (!compatible && itemCount > expectedFieldCount) {
        throw new Error(`Item count is more than required! Required: ${expectedFieldCount}, actual: ${itemCount}`);
    }
    if (requiredByteLength < firstOffset) {
        throw new Error(`First offset is larger than byte length: ${firstOffset}`);
    }
    const offsets = [];
    for (let i = 0; i < itemCount; i++) {
        const start = 4 + i * 4;
        offsets.push(view.getUint32(start, true));
    }
    offsets.push(requiredByteLength);
    for (let i = 0; i < offsets.length - 1; i++) {
        if (offsets[i] > offsets[i + 1]) {
            throw new Error(`Offset index ${i}: ${offsets[i]} is larger than offset index ${i + 1}: ${offsets[i + 1]}`);
        }
    }
    return offsets;
}
function serializeTable(buffers) {
    const itemCount = buffers.length;
    let totalSize = 4 * (itemCount + 1);
    const offsets = [];
    for (let i = 0; i < itemCount; i++) {
        offsets.push(totalSize);
        totalSize += buffers[i].byteLength;
    }
    const buffer = new ArrayBuffer(totalSize);
    const array = new Uint8Array(buffer);
    const view = new DataView(buffer);
    view.setUint32(0, totalSize, true);
    for (let i = 0; i < itemCount; i++) {
        view.setUint32(4 + i * 4, offsets[i], true);
        array.set(new Uint8Array(buffers[i]), offsets[i]);
    }
    return buffer;
}
class BlockMerkleState {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getMerkleRoot() {
        return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {
            validate: false,
        });
    }
    getCount() {
        return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), { validate: false });
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, BlockMerkleState.size());
        this.getMerkleRoot().validate(compatible);
        this.getCount().validate(compatible);
    }
    static size() {
        return 0 + Byte32.size() + Uint64.size();
    }
}
exports.BlockMerkleState = BlockMerkleState;
function SerializeBlockMerkleState(value) {
    const array = new Uint8Array(0 + Byte32.size() + Uint64.size());
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);
    array.set(new Uint8Array(SerializeUint64(value.count)), 0 + Byte32.size());
    return array.buffer;
}
exports.SerializeBlockMerkleState = SerializeBlockMerkleState;
class AccountMerkleState {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getMerkleRoot() {
        return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {
            validate: false,
        });
    }
    getCount() {
        return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), { validate: false });
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, AccountMerkleState.size());
        this.getMerkleRoot().validate(compatible);
        this.getCount().validate(compatible);
    }
    static size() {
        return 0 + Byte32.size() + Uint32.size();
    }
}
exports.AccountMerkleState = AccountMerkleState;
function SerializeAccountMerkleState(value) {
    const array = new Uint8Array(0 + Byte32.size() + Uint32.size());
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeByte32(value.merkle_root)), 0);
    array.set(new Uint8Array(SerializeUint32(value.count)), 0 + Byte32.size());
    return array.buffer;
}
exports.SerializeAccountMerkleState = SerializeAccountMerkleState;
class GlobalState {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getRollupConfigHash() {
        return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {
            validate: false,
        });
    }
    getAccount() {
        return new AccountMerkleState(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + AccountMerkleState.size()), { validate: false });
    }
    getBlock() {
        return new BlockMerkleState(this.view.buffer.slice(0 + Byte32.size() + AccountMerkleState.size(), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size()), { validate: false });
    }
    getRevertedBlockRoot() {
        return new Byte32(this.view.buffer.slice(0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size(), 0 +
            Byte32.size() +
            AccountMerkleState.size() +
            BlockMerkleState.size() +
            Byte32.size()), { validate: false });
    }
    getTipBlockHash() {
        return new Byte32(this.view.buffer.slice(0 +
            Byte32.size() +
            AccountMerkleState.size() +
            BlockMerkleState.size() +
            Byte32.size(), 0 +
            Byte32.size() +
            AccountMerkleState.size() +
            BlockMerkleState.size() +
            Byte32.size() +
            Byte32.size()), { validate: false });
    }
    getLastFinalizedBlockNumber() {
        return new Uint64(this.view.buffer.slice(0 +
            Byte32.size() +
            AccountMerkleState.size() +
            BlockMerkleState.size() +
            Byte32.size() +
            Byte32.size(), 0 +
            Byte32.size() +
            AccountMerkleState.size() +
            BlockMerkleState.size() +
            Byte32.size() +
            Byte32.size() +
            Uint64.size()), { validate: false });
    }
    getStatus() {
        return this.view.getUint8(0 +
            Byte32.size() +
            AccountMerkleState.size() +
            BlockMerkleState.size() +
            Byte32.size() +
            Byte32.size() +
            Uint64.size());
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, GlobalState.size());
        this.getRollupConfigHash().validate(compatible);
        this.getAccount().validate(compatible);
        this.getBlock().validate(compatible);
        this.getRevertedBlockRoot().validate(compatible);
        this.getTipBlockHash().validate(compatible);
        this.getLastFinalizedBlockNumber().validate(compatible);
    }
    static size() {
        return (0 +
            Byte32.size() +
            AccountMerkleState.size() +
            BlockMerkleState.size() +
            Byte32.size() +
            Byte32.size() +
            Uint64.size() +
            1);
    }
}
exports.GlobalState = GlobalState;
function SerializeGlobalState(value) {
    const array = new Uint8Array(0 +
        Byte32.size() +
        AccountMerkleState.size() +
        BlockMerkleState.size() +
        Byte32.size() +
        Byte32.size() +
        Uint64.size() +
        1);
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeByte32(value.rollup_config_hash)), 0);
    array.set(new Uint8Array(SerializeAccountMerkleState(value.account)), 0 + Byte32.size());
    array.set(new Uint8Array(SerializeBlockMerkleState(value.block)), 0 + Byte32.size() + AccountMerkleState.size());
    array.set(new Uint8Array(SerializeByte32(value.reverted_block_root)), 0 + Byte32.size() + AccountMerkleState.size() + BlockMerkleState.size());
    array.set(new Uint8Array(SerializeByte32(value.tip_block_hash)), 0 +
        Byte32.size() +
        AccountMerkleState.size() +
        BlockMerkleState.size() +
        Byte32.size());
    array.set(new Uint8Array(SerializeUint64(value.last_finalized_block_number)), 0 +
        Byte32.size() +
        AccountMerkleState.size() +
        BlockMerkleState.size() +
        Byte32.size() +
        Byte32.size());
    view.setUint8(0 +
        Byte32.size() +
        AccountMerkleState.size() +
        BlockMerkleState.size() +
        Byte32.size() +
        Byte32.size() +
        Uint64.size(), value.status);
    return array.buffer;
}
exports.SerializeGlobalState = SerializeGlobalState;
class RollupConfig {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
        new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), {
            validate: false,
        }).validate();
        new Byte32(this.view.buffer.slice(offsets[4], offsets[5]), {
            validate: false,
        }).validate();
        new Byte32(this.view.buffer.slice(offsets[5], offsets[6]), {
            validate: false,
        }).validate();
        new Byte32(this.view.buffer.slice(offsets[6], offsets[7]), {
            validate: false,
        }).validate();
        new Byte32(this.view.buffer.slice(offsets[7], offsets[8]), {
            validate: false,
        }).validate();
        new Uint64(this.view.buffer.slice(offsets[8], offsets[9]), {
            validate: false,
        }).validate();
        new Uint64(this.view.buffer.slice(offsets[9], offsets[10]), {
            validate: false,
        }).validate();
        new Uint64(this.view.buffer.slice(offsets[10], offsets[11]), {
            validate: false,
        }).validate();
        if (offsets[12] - offsets[11] !== 1) {
            throw new Error(`Invalid offset for reward_burn_rate: ${offsets[11]} - ${offsets[12]}`);
        }
        new Byte32Vec(this.view.buffer.slice(offsets[12], offsets[13]), {
            validate: false,
        }).validate();
        new Byte32Vec(this.view.buffer.slice(offsets[13], offsets[14]), {
            validate: false,
        }).validate();
    }
    getL1SudtScriptTypeHash() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getCustodianScriptTypeHash() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getDepositScriptTypeHash() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getWithdrawalScriptTypeHash() {
        const start = 16;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getChallengeScriptTypeHash() {
        const start = 20;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getStakeScriptTypeHash() {
        const start = 24;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getL2SudtValidatorScriptTypeHash() {
        const start = 28;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getBurnLockHash() {
        const start = 32;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getRequiredStakingCapacity() {
        const start = 36;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint64(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getChallengeMaturityBlocks() {
        const start = 40;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint64(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getFinalityBlocks() {
        const start = 44;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint64(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getRewardBurnRate() {
        const start = 48;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);
    }
    getAllowedEoaTypeHashes() {
        const start = 52;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32Vec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getAllowedContractTypeHashes() {
        const start = 56;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Byte32Vec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.RollupConfig = RollupConfig;
function SerializeRollupConfig(value) {
    const buffers = [];
    buffers.push(SerializeByte32(value.l1_sudt_script_type_hash));
    buffers.push(SerializeByte32(value.custodian_script_type_hash));
    buffers.push(SerializeByte32(value.deposit_script_type_hash));
    buffers.push(SerializeByte32(value.withdrawal_script_type_hash));
    buffers.push(SerializeByte32(value.challenge_script_type_hash));
    buffers.push(SerializeByte32(value.stake_script_type_hash));
    buffers.push(SerializeByte32(value.l2_sudt_validator_script_type_hash));
    buffers.push(SerializeByte32(value.burn_lock_hash));
    buffers.push(SerializeUint64(value.required_staking_capacity));
    buffers.push(SerializeUint64(value.challenge_maturity_blocks));
    buffers.push(SerializeUint64(value.finality_blocks));
    const rewardBurnRateView = new DataView(new ArrayBuffer(1));
    rewardBurnRateView.setUint8(0, value.reward_burn_rate);
    buffers.push(rewardBurnRateView.buffer);
    buffers.push(SerializeByte32Vec(value.allowed_eoa_type_hashes));
    buffers.push(SerializeByte32Vec(value.allowed_contract_type_hashes));
    return serializeTable(buffers);
}
exports.SerializeRollupConfig = SerializeRollupConfig;
class RawL2Transaction {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Uint32(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), {
            validate: false,
        }).validate();
    }
    getFromId() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getToId() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getNonce() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getArgs() {
        const start = 16;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.RawL2Transaction = RawL2Transaction;
function SerializeRawL2Transaction(value) {
    const buffers = [];
    buffers.push(SerializeUint32(value.from_id));
    buffers.push(SerializeUint32(value.to_id));
    buffers.push(SerializeUint32(value.nonce));
    buffers.push(SerializeBytes(value.args));
    return serializeTable(buffers);
}
exports.SerializeRawL2Transaction = SerializeRawL2Transaction;
class L2Transaction {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new RawL2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
    }
    getRaw() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new RawL2Transaction(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getSignature() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.L2Transaction = L2Transaction;
function SerializeL2Transaction(value) {
    const buffers = [];
    buffers.push(SerializeRawL2Transaction(value.raw));
    buffers.push(SerializeBytes(value.signature));
    return serializeTable(buffers);
}
exports.SerializeL2Transaction = SerializeL2Transaction;
class L2TransactionVec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        for (let i = 0; i < len(offsets) - 1; i++) {
            new L2Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
                validate: false,
            }).validate();
        }
    }
    length() {
        if (this.view.byteLength < 8) {
            return 0;
        }
        else {
            return this.view.getUint32(4, true) / 4 - 1;
        }
    }
    indexAt(i) {
        const start = 4 + i * 4;
        const offset = this.view.getUint32(start, true);
        let offset_end = this.view.byteLength;
        if (i + 1 < this.length()) {
            offset_end = this.view.getUint32(start + 4, true);
        }
        return new L2Transaction(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.L2TransactionVec = L2TransactionVec;
function SerializeL2TransactionVec(value) {
    return serializeTable(value.map((item) => SerializeL2Transaction(item)));
}
exports.SerializeL2TransactionVec = SerializeL2TransactionVec;
class SubmitTransactions {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
    }
    getTxWitnessRoot() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getTxCount() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getPrevStateCheckpoint() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.SubmitTransactions = SubmitTransactions;
function SerializeSubmitTransactions(value) {
    const buffers = [];
    buffers.push(SerializeByte32(value.tx_witness_root));
    buffers.push(SerializeUint32(value.tx_count));
    buffers.push(SerializeByte32(value.prev_state_checkpoint));
    return serializeTable(buffers);
}
exports.SerializeSubmitTransactions = SerializeSubmitTransactions;
class SubmitWithdrawals {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getWithdrawalWitnessRoot() {
        return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {
            validate: false,
        });
    }
    getWithdrawalCount() {
        return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), { validate: false });
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, SubmitWithdrawals.size());
        this.getWithdrawalWitnessRoot().validate(compatible);
        this.getWithdrawalCount().validate(compatible);
    }
    static size() {
        return 0 + Byte32.size() + Uint32.size();
    }
}
exports.SubmitWithdrawals = SubmitWithdrawals;
function SerializeSubmitWithdrawals(value) {
    const array = new Uint8Array(0 + Byte32.size() + Uint32.size());
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeByte32(value.withdrawal_witness_root)), 0);
    array.set(new Uint8Array(SerializeUint32(value.withdrawal_count)), 0 + Byte32.size());
    return array.buffer;
}
exports.SerializeSubmitWithdrawals = SerializeSubmitWithdrawals;
class RawL2Block {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Uint32(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
        new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), {
            validate: false,
        }).validate();
        new Uint64(this.view.buffer.slice(offsets[4], offsets[5]), {
            validate: false,
        }).validate();
        new AccountMerkleState(this.view.buffer.slice(offsets[5], offsets[6]), {
            validate: false,
        }).validate();
        new AccountMerkleState(this.view.buffer.slice(offsets[6], offsets[7]), {
            validate: false,
        }).validate();
        new Byte32Vec(this.view.buffer.slice(offsets[7], offsets[8]), {
            validate: false,
        }).validate();
        new SubmitWithdrawals(this.view.buffer.slice(offsets[8], offsets[9]), {
            validate: false,
        }).validate();
        new SubmitTransactions(this.view.buffer.slice(offsets[9], offsets[10]), {
            validate: false,
        }).validate();
    }
    getNumber() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint64(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getBlockProducerId() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getParentBlockHash() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getStakeCellOwnerLockHash() {
        const start = 16;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getTimestamp() {
        const start = 20;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint64(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getPrevAccount() {
        const start = 24;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getPostAccount() {
        const start = 28;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new AccountMerkleState(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getStateCheckpointList() {
        const start = 32;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32Vec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getSubmitWithdrawals() {
        const start = 36;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new SubmitWithdrawals(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getSubmitTransactions() {
        const start = 40;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new SubmitTransactions(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.RawL2Block = RawL2Block;
function SerializeRawL2Block(value) {
    const buffers = [];
    buffers.push(SerializeUint64(value.number));
    buffers.push(SerializeUint32(value.block_producer_id));
    buffers.push(SerializeByte32(value.parent_block_hash));
    buffers.push(SerializeByte32(value.stake_cell_owner_lock_hash));
    buffers.push(SerializeUint64(value.timestamp));
    buffers.push(SerializeAccountMerkleState(value.prev_account));
    buffers.push(SerializeAccountMerkleState(value.post_account));
    buffers.push(SerializeByte32Vec(value.state_checkpoint_list));
    buffers.push(SerializeSubmitWithdrawals(value.submit_withdrawals));
    buffers.push(SerializeSubmitTransactions(value.submit_transactions));
    return serializeTable(buffers);
}
exports.SerializeRawL2Block = SerializeRawL2Block;
class RawL2BlockVec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        for (let i = 0; i < len(offsets) - 1; i++) {
            new RawL2Block(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
                validate: false,
            }).validate();
        }
    }
    length() {
        if (this.view.byteLength < 8) {
            return 0;
        }
        else {
            return this.view.getUint32(4, true) / 4 - 1;
        }
    }
    indexAt(i) {
        const start = 4 + i * 4;
        const offset = this.view.getUint32(start, true);
        let offset_end = this.view.byteLength;
        if (i + 1 < this.length()) {
            offset_end = this.view.getUint32(start + 4, true);
        }
        return new RawL2Block(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.RawL2BlockVec = RawL2BlockVec;
function SerializeRawL2BlockVec(value) {
    return serializeTable(value.map((item) => SerializeRawL2Block(item)));
}
exports.SerializeRawL2BlockVec = SerializeRawL2BlockVec;
class L2Block {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
        new L2TransactionVec(this.view.buffer.slice(offsets[3], offsets[4]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), {
            validate: false,
        }).validate();
        new WithdrawalRequestVec(this.view.buffer.slice(offsets[5], offsets[6]), {
            validate: false,
        }).validate();
    }
    getRaw() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new RawL2Block(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getKvState() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new KVPairVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getKvStateProof() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getTransactions() {
        const start = 16;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new L2TransactionVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getBlockProof() {
        const start = 20;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getWithdrawals() {
        const start = 24;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new WithdrawalRequestVec(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
}
exports.L2Block = L2Block;
function SerializeL2Block(value) {
    const buffers = [];
    buffers.push(SerializeRawL2Block(value.raw));
    buffers.push(SerializeKVPairVec(value.kv_state));
    buffers.push(SerializeBytes(value.kv_state_proof));
    buffers.push(SerializeL2TransactionVec(value.transactions));
    buffers.push(SerializeBytes(value.block_proof));
    buffers.push(SerializeWithdrawalRequestVec(value.withdrawals));
    return serializeTable(buffers);
}
exports.SerializeL2Block = SerializeL2Block;
class DepositRequest {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Byte32(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
        new Script(this.view.buffer.slice(offsets[3], offsets[4]), {
            validate: false,
        }).validate();
    }
    getCapacity() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint64(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getAmount() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint128(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getSudtScriptHash() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getScript() {
        const start = 16;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Script(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.DepositRequest = DepositRequest;
function SerializeDepositRequest(value) {
    const buffers = [];
    buffers.push(SerializeUint64(value.capacity));
    buffers.push(SerializeUint128(value.amount));
    buffers.push(SerializeByte32(value.sudt_script_hash));
    buffers.push(SerializeScript(value.script));
    return serializeTable(buffers);
}
exports.SerializeDepositRequest = SerializeDepositRequest;
class DepositRequestVec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        for (let i = 0; i < len(offsets) - 1; i++) {
            new DepositRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
                validate: false,
            }).validate();
        }
    }
    length() {
        if (this.view.byteLength < 8) {
            return 0;
        }
        else {
            return this.view.getUint32(4, true) / 4 - 1;
        }
    }
    indexAt(i) {
        const start = 4 + i * 4;
        const offset = this.view.getUint32(start, true);
        let offset_end = this.view.byteLength;
        if (i + 1 < this.length()) {
            offset_end = this.view.getUint32(start + 4, true);
        }
        return new DepositRequest(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.DepositRequestVec = DepositRequestVec;
function SerializeDepositRequestVec(value) {
    return serializeTable(value.map((item) => SerializeDepositRequest(item)));
}
exports.SerializeDepositRequestVec = SerializeDepositRequestVec;
class RawWithdrawalRequest {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getNonce() {
        return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), {
            validate: false,
        });
    }
    getCapacity() {
        return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), { validate: false });
    }
    getAmount() {
        return new Uint128(this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size()), { validate: false });
    }
    getSudtScriptHash() {
        return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint64.size() + Uint128.size(), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size()), { validate: false });
    }
    getAccountScriptHash() {
        return new Byte32(this.view.buffer.slice(0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size(), 0 +
            Uint32.size() +
            Uint64.size() +
            Uint128.size() +
            Byte32.size() +
            Byte32.size()), { validate: false });
    }
    getSellAmount() {
        return new Uint128(this.view.buffer.slice(0 +
            Uint32.size() +
            Uint64.size() +
            Uint128.size() +
            Byte32.size() +
            Byte32.size(), 0 +
            Uint32.size() +
            Uint64.size() +
            Uint128.size() +
            Byte32.size() +
            Byte32.size() +
            Uint128.size()), { validate: false });
    }
    getSellCapacity() {
        return new Uint64(this.view.buffer.slice(0 +
            Uint32.size() +
            Uint64.size() +
            Uint128.size() +
            Byte32.size() +
            Byte32.size() +
            Uint128.size(), 0 +
            Uint32.size() +
            Uint64.size() +
            Uint128.size() +
            Byte32.size() +
            Byte32.size() +
            Uint128.size() +
            Uint64.size()), { validate: false });
    }
    getOwnerLockHash() {
        return new Byte32(this.view.buffer.slice(0 +
            Uint32.size() +
            Uint64.size() +
            Uint128.size() +
            Byte32.size() +
            Byte32.size() +
            Uint128.size() +
            Uint64.size(), 0 +
            Uint32.size() +
            Uint64.size() +
            Uint128.size() +
            Byte32.size() +
            Byte32.size() +
            Uint128.size() +
            Uint64.size() +
            Byte32.size()), { validate: false });
    }
    getPaymentLockHash() {
        return new Byte32(this.view.buffer.slice(0 +
            Uint32.size() +
            Uint64.size() +
            Uint128.size() +
            Byte32.size() +
            Byte32.size() +
            Uint128.size() +
            Uint64.size() +
            Byte32.size(), 0 +
            Uint32.size() +
            Uint64.size() +
            Uint128.size() +
            Byte32.size() +
            Byte32.size() +
            Uint128.size() +
            Uint64.size() +
            Byte32.size() +
            Byte32.size()), { validate: false });
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, RawWithdrawalRequest.size());
        this.getNonce().validate(compatible);
        this.getCapacity().validate(compatible);
        this.getAmount().validate(compatible);
        this.getSudtScriptHash().validate(compatible);
        this.getAccountScriptHash().validate(compatible);
        this.getSellAmount().validate(compatible);
        this.getSellCapacity().validate(compatible);
        this.getOwnerLockHash().validate(compatible);
        this.getPaymentLockHash().validate(compatible);
    }
    static size() {
        return (0 +
            Uint32.size() +
            Uint64.size() +
            Uint128.size() +
            Byte32.size() +
            Byte32.size() +
            Uint128.size() +
            Uint64.size() +
            Byte32.size() +
            Byte32.size());
    }
}
exports.RawWithdrawalRequest = RawWithdrawalRequest;
function SerializeRawWithdrawalRequest(value) {
    const array = new Uint8Array(0 +
        Uint32.size() +
        Uint64.size() +
        Uint128.size() +
        Byte32.size() +
        Byte32.size() +
        Uint128.size() +
        Uint64.size() +
        Byte32.size() +
        Byte32.size());
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeUint32(value.nonce)), 0);
    array.set(new Uint8Array(SerializeUint64(value.capacity)), 0 + Uint32.size());
    array.set(new Uint8Array(SerializeUint128(value.amount)), 0 + Uint32.size() + Uint64.size());
    array.set(new Uint8Array(SerializeByte32(value.sudt_script_hash)), 0 + Uint32.size() + Uint64.size() + Uint128.size());
    array.set(new Uint8Array(SerializeByte32(value.account_script_hash)), 0 + Uint32.size() + Uint64.size() + Uint128.size() + Byte32.size());
    array.set(new Uint8Array(SerializeUint128(value.sell_amount)), 0 +
        Uint32.size() +
        Uint64.size() +
        Uint128.size() +
        Byte32.size() +
        Byte32.size());
    array.set(new Uint8Array(SerializeUint64(value.sell_capacity)), 0 +
        Uint32.size() +
        Uint64.size() +
        Uint128.size() +
        Byte32.size() +
        Byte32.size() +
        Uint128.size());
    array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0 +
        Uint32.size() +
        Uint64.size() +
        Uint128.size() +
        Byte32.size() +
        Byte32.size() +
        Uint128.size() +
        Uint64.size());
    array.set(new Uint8Array(SerializeByte32(value.payment_lock_hash)), 0 +
        Uint32.size() +
        Uint64.size() +
        Uint128.size() +
        Byte32.size() +
        Byte32.size() +
        Uint128.size() +
        Uint64.size() +
        Byte32.size());
    return array.buffer;
}
exports.SerializeRawWithdrawalRequest = SerializeRawWithdrawalRequest;
class WithdrawalRequestVec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        for (let i = 0; i < len(offsets) - 1; i++) {
            new WithdrawalRequest(this.view.buffer.slice(offsets[i], offsets[i + 1]), { validate: false }).validate();
        }
    }
    length() {
        if (this.view.byteLength < 8) {
            return 0;
        }
        else {
            return this.view.getUint32(4, true) / 4 - 1;
        }
    }
    indexAt(i) {
        const start = 4 + i * 4;
        const offset = this.view.getUint32(start, true);
        let offset_end = this.view.byteLength;
        if (i + 1 < this.length()) {
            offset_end = this.view.getUint32(start + 4, true);
        }
        return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.WithdrawalRequestVec = WithdrawalRequestVec;
function SerializeWithdrawalRequestVec(value) {
    return serializeTable(value.map((item) => SerializeWithdrawalRequest(item)));
}
exports.SerializeWithdrawalRequestVec = SerializeWithdrawalRequestVec;
class WithdrawalRequest {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new RawWithdrawalRequest(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
    }
    getRaw() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new RawWithdrawalRequest(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
    getSignature() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.WithdrawalRequest = WithdrawalRequest;
function SerializeWithdrawalRequest(value) {
    const buffers = [];
    buffers.push(SerializeRawWithdrawalRequest(value.raw));
    buffers.push(SerializeBytes(value.signature));
    return serializeTable(buffers);
}
exports.SerializeWithdrawalRequest = SerializeWithdrawalRequest;
class KVPair {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
    }
    getK() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getV() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.KVPair = KVPair;
function SerializeKVPair(value) {
    const buffers = [];
    buffers.push(SerializeByte32(value.k));
    buffers.push(SerializeByte32(value.v));
    return serializeTable(buffers);
}
exports.SerializeKVPair = SerializeKVPair;
class KVPairVec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        for (let i = 0; i < len(offsets) - 1; i++) {
            new KVPair(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
                validate: false,
            }).validate();
        }
    }
    length() {
        if (this.view.byteLength < 8) {
            return 0;
        }
        else {
            return this.view.getUint32(4, true) / 4 - 1;
        }
    }
    indexAt(i) {
        const start = 4 + i * 4;
        const offset = this.view.getUint32(start, true);
        let offset_end = this.view.byteLength;
        if (i + 1 < this.length()) {
            offset_end = this.view.getUint32(start + 4, true);
        }
        return new KVPair(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.KVPairVec = KVPairVec;
function SerializeKVPairVec(value) {
    return serializeTable(value.map((item) => SerializeKVPair(item)));
}
exports.SerializeKVPairVec = SerializeKVPairVec;
class BlockInfo {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getBlockProducerId() {
        return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), {
            validate: false,
        });
    }
    getNumber() {
        return new Uint64(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint64.size()), { validate: false });
    }
    getTimestamp() {
        return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint64.size() + Uint64.size()), { validate: false });
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, BlockInfo.size());
        this.getBlockProducerId().validate(compatible);
        this.getNumber().validate(compatible);
        this.getTimestamp().validate(compatible);
    }
    static size() {
        return 0 + Uint32.size() + Uint64.size() + Uint64.size();
    }
}
exports.BlockInfo = BlockInfo;
function SerializeBlockInfo(value) {
    const array = new Uint8Array(0 + Uint32.size() + Uint64.size() + Uint64.size());
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeUint32(value.block_producer_id)), 0);
    array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size());
    array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint64.size());
    return array.buffer;
}
exports.SerializeBlockInfo = SerializeBlockInfo;
class DepositLockArgs {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Script(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
    }
    getOwnerLockHash() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getLayer2Lock() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Script(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getCancelTimeout() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Uint64(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.DepositLockArgs = DepositLockArgs;
function SerializeDepositLockArgs(value) {
    const buffers = [];
    buffers.push(SerializeByte32(value.owner_lock_hash));
    buffers.push(SerializeScript(value.layer2_lock));
    buffers.push(SerializeUint64(value.cancel_timeout));
    return serializeTable(buffers);
}
exports.SerializeDepositLockArgs = SerializeDepositLockArgs;
class CustodianLockArgs {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new DepositLockArgs(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Byte32(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Uint64(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
    }
    getDepositLockArgs() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new DepositLockArgs(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getDepositBlockHash() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getDepositBlockNumber() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Uint64(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.CustodianLockArgs = CustodianLockArgs;
function SerializeCustodianLockArgs(value) {
    const buffers = [];
    buffers.push(SerializeDepositLockArgs(value.deposit_lock_args));
    buffers.push(SerializeByte32(value.deposit_block_hash));
    buffers.push(SerializeUint64(value.deposit_block_number));
    return serializeTable(buffers);
}
exports.SerializeCustodianLockArgs = SerializeCustodianLockArgs;
class UnlockCustodianViaRevertWitness {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getDepositLockHash() {
        return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {
            validate: false,
        });
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, UnlockCustodianViaRevertWitness.size());
        this.getDepositLockHash().validate(compatible);
    }
    static size() {
        return 0 + Byte32.size();
    }
}
exports.UnlockCustodianViaRevertWitness = UnlockCustodianViaRevertWitness;
function SerializeUnlockCustodianViaRevertWitness(value) {
    const array = new Uint8Array(0 + Byte32.size());
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeByte32(value.deposit_lock_hash)), 0);
    return array.buffer;
}
exports.SerializeUnlockCustodianViaRevertWitness = SerializeUnlockCustodianViaRevertWitness;
class WithdrawalLockArgs {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getAccountScriptHash() {
        return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {
            validate: false,
        });
    }
    getWithdrawalBlockHash() {
        return new Byte32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Byte32.size()), { validate: false });
    }
    getWithdrawalBlockNumber() {
        return new Uint64(this.view.buffer.slice(0 + Byte32.size() + Byte32.size(), 0 + Byte32.size() + Byte32.size() + Uint64.size()), { validate: false });
    }
    getSudtScriptHash() {
        return new Byte32(this.view.buffer.slice(0 + Byte32.size() + Byte32.size() + Uint64.size(), 0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size()), { validate: false });
    }
    getSellAmount() {
        return new Uint128(this.view.buffer.slice(0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size(), 0 +
            Byte32.size() +
            Byte32.size() +
            Uint64.size() +
            Byte32.size() +
            Uint128.size()), { validate: false });
    }
    getSellCapacity() {
        return new Uint64(this.view.buffer.slice(0 +
            Byte32.size() +
            Byte32.size() +
            Uint64.size() +
            Byte32.size() +
            Uint128.size(), 0 +
            Byte32.size() +
            Byte32.size() +
            Uint64.size() +
            Byte32.size() +
            Uint128.size() +
            Uint64.size()), { validate: false });
    }
    getOwnerLockHash() {
        return new Byte32(this.view.buffer.slice(0 +
            Byte32.size() +
            Byte32.size() +
            Uint64.size() +
            Byte32.size() +
            Uint128.size() +
            Uint64.size(), 0 +
            Byte32.size() +
            Byte32.size() +
            Uint64.size() +
            Byte32.size() +
            Uint128.size() +
            Uint64.size() +
            Byte32.size()), { validate: false });
    }
    getPaymentLockHash() {
        return new Byte32(this.view.buffer.slice(0 +
            Byte32.size() +
            Byte32.size() +
            Uint64.size() +
            Byte32.size() +
            Uint128.size() +
            Uint64.size() +
            Byte32.size(), 0 +
            Byte32.size() +
            Byte32.size() +
            Uint64.size() +
            Byte32.size() +
            Uint128.size() +
            Uint64.size() +
            Byte32.size() +
            Byte32.size()), { validate: false });
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, WithdrawalLockArgs.size());
        this.getAccountScriptHash().validate(compatible);
        this.getWithdrawalBlockHash().validate(compatible);
        this.getWithdrawalBlockNumber().validate(compatible);
        this.getSudtScriptHash().validate(compatible);
        this.getSellAmount().validate(compatible);
        this.getSellCapacity().validate(compatible);
        this.getOwnerLockHash().validate(compatible);
        this.getPaymentLockHash().validate(compatible);
    }
    static size() {
        return (0 +
            Byte32.size() +
            Byte32.size() +
            Uint64.size() +
            Byte32.size() +
            Uint128.size() +
            Uint64.size() +
            Byte32.size() +
            Byte32.size());
    }
}
exports.WithdrawalLockArgs = WithdrawalLockArgs;
function SerializeWithdrawalLockArgs(value) {
    const array = new Uint8Array(0 +
        Byte32.size() +
        Byte32.size() +
        Uint64.size() +
        Byte32.size() +
        Uint128.size() +
        Uint64.size() +
        Byte32.size() +
        Byte32.size());
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeByte32(value.account_script_hash)), 0);
    array.set(new Uint8Array(SerializeByte32(value.withdrawal_block_hash)), 0 + Byte32.size());
    array.set(new Uint8Array(SerializeUint64(value.withdrawal_block_number)), 0 + Byte32.size() + Byte32.size());
    array.set(new Uint8Array(SerializeByte32(value.sudt_script_hash)), 0 + Byte32.size() + Byte32.size() + Uint64.size());
    array.set(new Uint8Array(SerializeUint128(value.sell_amount)), 0 + Byte32.size() + Byte32.size() + Uint64.size() + Byte32.size());
    array.set(new Uint8Array(SerializeUint64(value.sell_capacity)), 0 +
        Byte32.size() +
        Byte32.size() +
        Uint64.size() +
        Byte32.size() +
        Uint128.size());
    array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0 +
        Byte32.size() +
        Byte32.size() +
        Uint64.size() +
        Byte32.size() +
        Uint128.size() +
        Uint64.size());
    array.set(new Uint8Array(SerializeByte32(value.payment_lock_hash)), 0 +
        Byte32.size() +
        Byte32.size() +
        Uint64.size() +
        Byte32.size() +
        Uint128.size() +
        Uint64.size() +
        Byte32.size());
    return array.buffer;
}
exports.SerializeWithdrawalLockArgs = SerializeWithdrawalLockArgs;
class UnlockWithdrawalWitness {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        if (this.view.byteLength < 4) {
            assertDataLength(this.view.byteLength, ">4");
        }
        const t = this.view.getUint32(0, true);
        switch (t) {
            case 0:
                new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), {
                    validate: false,
                }).validate();
                break;
            case 1:
                new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), {
                    validate: false,
                }).validate();
                break;
            case 2:
                new UnlockWithdrawalViaTrade(this.view.buffer.slice(4), {
                    validate: false,
                }).validate();
                break;
            default:
                throw new Error(`Invalid type: ${t}`);
        }
    }
    unionType() {
        const t = this.view.getUint32(0, true);
        switch (t) {
            case 0:
                return "UnlockWithdrawalViaFinalize";
            case 1:
                return "UnlockWithdrawalViaRevert";
            case 2:
                return "UnlockWithdrawalViaTrade";
            default:
                throw new Error(`Invalid type: ${t}`);
        }
    }
    value() {
        const t = this.view.getUint32(0, true);
        switch (t) {
            case 0:
                return new UnlockWithdrawalViaFinalize(this.view.buffer.slice(4), {
                    validate: false,
                });
            case 1:
                return new UnlockWithdrawalViaRevert(this.view.buffer.slice(4), {
                    validate: false,
                });
            case 2:
                return new UnlockWithdrawalViaTrade(this.view.buffer.slice(4), {
                    validate: false,
                });
            default:
                throw new Error(`Invalid type: ${t}`);
        }
    }
}
exports.UnlockWithdrawalWitness = UnlockWithdrawalWitness;
function SerializeUnlockWithdrawalWitness(value) {
    switch (value.type) {
        case "UnlockWithdrawalViaFinalize": {
            const itemBuffer = SerializeUnlockWithdrawalViaFinalize(value.value);
            const array = new Uint8Array(4 + itemBuffer.byteLength);
            const view = new DataView(array.buffer);
            view.setUint32(0, 0, true);
            array.set(new Uint8Array(itemBuffer), 4);
            return array.buffer;
        }
        case "UnlockWithdrawalViaRevert": {
            const itemBuffer = SerializeUnlockWithdrawalViaRevert(value.value);
            const array = new Uint8Array(4 + itemBuffer.byteLength);
            const view = new DataView(array.buffer);
            view.setUint32(0, 1, true);
            array.set(new Uint8Array(itemBuffer), 4);
            return array.buffer;
        }
        case "UnlockWithdrawalViaTrade": {
            const itemBuffer = SerializeUnlockWithdrawalViaTrade(value.value);
            const array = new Uint8Array(4 + itemBuffer.byteLength);
            const view = new DataView(array.buffer);
            view.setUint32(0, 2, true);
            array.set(new Uint8Array(itemBuffer), 4);
            return array.buffer;
        }
        default:
            throw new Error(`Invalid type: ${value.type}`);
    }
}
exports.SerializeUnlockWithdrawalWitness = SerializeUnlockWithdrawalWitness;
class UnlockWithdrawalViaFinalize {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
    }
}
exports.UnlockWithdrawalViaFinalize = UnlockWithdrawalViaFinalize;
function SerializeUnlockWithdrawalViaFinalize(value) {
    const buffers = [];
    return serializeTable(buffers);
}
exports.SerializeUnlockWithdrawalViaFinalize = SerializeUnlockWithdrawalViaFinalize;
class UnlockWithdrawalViaRevert {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getCustodianLockHash() {
        return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {
            validate: false,
        });
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, UnlockWithdrawalViaRevert.size());
        this.getCustodianLockHash().validate(compatible);
    }
    static size() {
        return 0 + Byte32.size();
    }
}
exports.UnlockWithdrawalViaRevert = UnlockWithdrawalViaRevert;
function SerializeUnlockWithdrawalViaRevert(value) {
    const array = new Uint8Array(0 + Byte32.size());
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeByte32(value.custodian_lock_hash)), 0);
    return array.buffer;
}
exports.SerializeUnlockWithdrawalViaRevert = SerializeUnlockWithdrawalViaRevert;
class UnlockWithdrawalViaTrade {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Script(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
    }
    getOwnerLock() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Script(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.UnlockWithdrawalViaTrade = UnlockWithdrawalViaTrade;
function SerializeUnlockWithdrawalViaTrade(value) {
    const buffers = [];
    buffers.push(SerializeScript(value.owner_lock));
    return serializeTable(buffers);
}
exports.SerializeUnlockWithdrawalViaTrade = SerializeUnlockWithdrawalViaTrade;
class StakeLockArgs {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getOwnerLockHash() {
        return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {
            validate: false,
        });
    }
    getStakeBlockNumber() {
        return new Uint64(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint64.size()), { validate: false });
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, StakeLockArgs.size());
        this.getOwnerLockHash().validate(compatible);
        this.getStakeBlockNumber().validate(compatible);
    }
    static size() {
        return 0 + Byte32.size() + Uint64.size();
    }
}
exports.StakeLockArgs = StakeLockArgs;
function SerializeStakeLockArgs(value) {
    const array = new Uint8Array(0 + Byte32.size() + Uint64.size());
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeByte32(value.owner_lock_hash)), 0);
    array.set(new Uint8Array(SerializeUint64(value.stake_block_number)), 0 + Byte32.size());
    return array.buffer;
}
exports.SerializeStakeLockArgs = SerializeStakeLockArgs;
class MetaContractArgs {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        if (this.view.byteLength < 4) {
            assertDataLength(this.view.byteLength, ">4");
        }
        const t = this.view.getUint32(0, true);
        switch (t) {
            case 0:
                new CreateAccount(this.view.buffer.slice(4), {
                    validate: false,
                }).validate();
                break;
            default:
                throw new Error(`Invalid type: ${t}`);
        }
    }
    unionType() {
        const t = this.view.getUint32(0, true);
        switch (t) {
            case 0:
                return "CreateAccount";
            default:
                throw new Error(`Invalid type: ${t}`);
        }
    }
    value() {
        const t = this.view.getUint32(0, true);
        switch (t) {
            case 0:
                return new CreateAccount(this.view.buffer.slice(4), {
                    validate: false,
                });
            default:
                throw new Error(`Invalid type: ${t}`);
        }
    }
}
exports.MetaContractArgs = MetaContractArgs;
function SerializeMetaContractArgs(value) {
    switch (value.type) {
        case "CreateAccount": {
            const itemBuffer = SerializeCreateAccount(value.value);
            const array = new Uint8Array(4 + itemBuffer.byteLength);
            const view = new DataView(array.buffer);
            view.setUint32(0, 0, true);
            array.set(new Uint8Array(itemBuffer), 4);
            return array.buffer;
        }
        default:
            throw new Error(`Invalid type: ${value.type}`);
    }
}
exports.SerializeMetaContractArgs = SerializeMetaContractArgs;
class CreateAccount {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Script(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
    }
    getScript() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Script(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.CreateAccount = CreateAccount;
function SerializeCreateAccount(value) {
    const buffers = [];
    buffers.push(SerializeScript(value.script));
    return serializeTable(buffers);
}
exports.SerializeCreateAccount = SerializeCreateAccount;
class SUDTArgs {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        if (this.view.byteLength < 4) {
            assertDataLength(this.view.byteLength, ">4");
        }
        const t = this.view.getUint32(0, true);
        switch (t) {
            case 0:
                new SUDTQuery(this.view.buffer.slice(4), {
                    validate: false,
                }).validate();
                break;
            case 1:
                new SUDTTransfer(this.view.buffer.slice(4), {
                    validate: false,
                }).validate();
                break;
            default:
                throw new Error(`Invalid type: ${t}`);
        }
    }
    unionType() {
        const t = this.view.getUint32(0, true);
        switch (t) {
            case 0:
                return "SUDTQuery";
            case 1:
                return "SUDTTransfer";
            default:
                throw new Error(`Invalid type: ${t}`);
        }
    }
    value() {
        const t = this.view.getUint32(0, true);
        switch (t) {
            case 0:
                return new SUDTQuery(this.view.buffer.slice(4), { validate: false });
            case 1:
                return new SUDTTransfer(this.view.buffer.slice(4), { validate: false });
            default:
                throw new Error(`Invalid type: ${t}`);
        }
    }
}
exports.SUDTArgs = SUDTArgs;
function SerializeSUDTArgs(value) {
    switch (value.type) {
        case "SUDTQuery": {
            const itemBuffer = SerializeSUDTQuery(value.value);
            const array = new Uint8Array(4 + itemBuffer.byteLength);
            const view = new DataView(array.buffer);
            view.setUint32(0, 0, true);
            array.set(new Uint8Array(itemBuffer), 4);
            return array.buffer;
        }
        case "SUDTTransfer": {
            const itemBuffer = SerializeSUDTTransfer(value.value);
            const array = new Uint8Array(4 + itemBuffer.byteLength);
            const view = new DataView(array.buffer);
            view.setUint32(0, 1, true);
            array.set(new Uint8Array(itemBuffer), 4);
            return array.buffer;
        }
        default:
            throw new Error(`Invalid type: ${value.type}`);
    }
}
exports.SerializeSUDTArgs = SerializeSUDTArgs;
class SUDTQuery {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
    }
    getShortAddress() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.SUDTQuery = SUDTQuery;
function SerializeSUDTQuery(value) {
    const buffers = [];
    buffers.push(SerializeBytes(value.short_address));
    return serializeTable(buffers);
}
exports.SerializeSUDTQuery = SerializeSUDTQuery;
class SUDTTransfer {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Bytes(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Uint128(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Uint128(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
    }
    getTo() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getAmount() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint128(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getFee() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Uint128(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.SUDTTransfer = SUDTTransfer;
function SerializeSUDTTransfer(value) {
    const buffers = [];
    buffers.push(SerializeBytes(value.to));
    buffers.push(SerializeUint128(value.amount));
    buffers.push(SerializeUint128(value.fee));
    return serializeTable(buffers);
}
exports.SerializeSUDTTransfer = SerializeSUDTTransfer;
class ChallengeTarget {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getBlockHash() {
        return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {
            validate: false,
        });
    }
    getTargetIndex() {
        return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), { validate: false });
    }
    getTargetType() {
        return this.view.getUint8(0 + Byte32.size() + Uint32.size());
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, ChallengeTarget.size());
        this.getBlockHash().validate(compatible);
        this.getTargetIndex().validate(compatible);
    }
    static size() {
        return 0 + Byte32.size() + Uint32.size() + 1;
    }
}
exports.ChallengeTarget = ChallengeTarget;
function SerializeChallengeTarget(value) {
    const array = new Uint8Array(0 + Byte32.size() + Uint32.size() + 1);
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeByte32(value.block_hash)), 0);
    array.set(new Uint8Array(SerializeUint32(value.target_index)), 0 + Byte32.size());
    view.setUint8(0 + Byte32.size() + Uint32.size(), value.target_type);
    return array.buffer;
}
exports.SerializeChallengeTarget = SerializeChallengeTarget;
class ChallengeLockArgs {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new ChallengeTarget(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Script(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
    }
    getTarget() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new ChallengeTarget(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getRewardsReceiverLock() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Script(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.ChallengeLockArgs = ChallengeLockArgs;
function SerializeChallengeLockArgs(value) {
    const buffers = [];
    buffers.push(SerializeChallengeTarget(value.target));
    buffers.push(SerializeScript(value.rewards_receiver_lock));
    return serializeTable(buffers);
}
exports.SerializeChallengeLockArgs = SerializeChallengeLockArgs;
class ChallengeWitness {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
    }
    getRawL2Block() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new RawL2Block(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getBlockProof() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.ChallengeWitness = ChallengeWitness;
function SerializeChallengeWitness(value) {
    const buffers = [];
    buffers.push(SerializeRawL2Block(value.raw_l2block));
    buffers.push(SerializeBytes(value.block_proof));
    return serializeTable(buffers);
}
exports.SerializeChallengeWitness = SerializeChallengeWitness;
class ScriptVec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        for (let i = 0; i < len(offsets) - 1; i++) {
            new Script(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
                validate: false,
            }).validate();
        }
    }
    length() {
        if (this.view.byteLength < 8) {
            return 0;
        }
        else {
            return this.view.getUint32(4, true) / 4 - 1;
        }
    }
    indexAt(i) {
        const start = 4 + i * 4;
        const offset = this.view.getUint32(start, true);
        let offset_end = this.view.byteLength;
        if (i + 1 < this.length()) {
            offset_end = this.view.getUint32(start + 4, true);
        }
        return new Script(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.ScriptVec = ScriptVec;
function SerializeScriptVec(value) {
    return serializeTable(value.map((item) => SerializeScript(item)));
}
exports.SerializeScriptVec = SerializeScriptVec;
class BlockHashEntry {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getNumber() {
        return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), {
            validate: false,
        });
    }
    getHash() {
        return new Byte32(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + Byte32.size()), { validate: false });
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, BlockHashEntry.size());
        this.getNumber().validate(compatible);
        this.getHash().validate(compatible);
    }
    static size() {
        return 0 + Uint64.size() + Byte32.size();
    }
}
exports.BlockHashEntry = BlockHashEntry;
function SerializeBlockHashEntry(value) {
    const array = new Uint8Array(0 + Uint64.size() + Byte32.size());
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeUint64(value.number)), 0);
    array.set(new Uint8Array(SerializeByte32(value.hash)), 0 + Uint64.size());
    return array.buffer;
}
exports.SerializeBlockHashEntry = SerializeBlockHashEntry;
class BlockHashEntryVec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        if (this.view.byteLength < 4) {
            dataLengthError(this.view.byteLength, ">4");
        }
        const requiredByteLength = this.length() * BlockHashEntry.size() + 4;
        assertDataLength(this.view.byteLength, requiredByteLength);
        for (let i = 0; i < 0; i++) {
            const item = this.indexAt(i);
            item.validate(compatible);
        }
    }
    indexAt(i) {
        return new BlockHashEntry(this.view.buffer.slice(4 + i * BlockHashEntry.size(), 4 + (i + 1) * BlockHashEntry.size()), { validate: false });
    }
    length() {
        return this.view.getUint32(0, true);
    }
}
exports.BlockHashEntryVec = BlockHashEntryVec;
function SerializeBlockHashEntryVec(value) {
    const array = new Uint8Array(4 + BlockHashEntry.size() * value.length);
    new DataView(array.buffer).setUint32(0, value.length, true);
    for (let i = 0; i < value.length; i++) {
        const itemBuffer = SerializeBlockHashEntry(value[i]);
        array.set(new Uint8Array(itemBuffer), 4 + i * BlockHashEntry.size());
    }
    return array.buffer;
}
exports.SerializeBlockHashEntryVec = SerializeBlockHashEntryVec;
class VerifyTransactionContext {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new ScriptVec(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
        new Byte32(this.view.buffer.slice(offsets[3], offsets[4]), {
            validate: false,
        }).validate();
        new BlockHashEntryVec(this.view.buffer.slice(offsets[4], offsets[5]), {
            validate: false,
        }).validate();
    }
    getAccountCount() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getKvState() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new KVPairVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getScripts() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new ScriptVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getReturnDataHash() {
        const start = 16;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getBlockHashes() {
        const start = 20;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new BlockHashEntryVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.VerifyTransactionContext = VerifyTransactionContext;
function SerializeVerifyTransactionContext(value) {
    const buffers = [];
    buffers.push(SerializeUint32(value.account_count));
    buffers.push(SerializeKVPairVec(value.kv_state));
    buffers.push(SerializeScriptVec(value.scripts));
    buffers.push(SerializeByte32(value.return_data_hash));
    buffers.push(SerializeBlockHashEntryVec(value.block_hashes));
    return serializeTable(buffers);
}
exports.SerializeVerifyTransactionContext = SerializeVerifyTransactionContext;
class VerifyTransactionWitness {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new L2Transaction(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new RawL2Block(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[4], offsets[5]), {
            validate: false,
        }).validate();
        new VerifyTransactionContext(this.view.buffer.slice(offsets[5], offsets[6]), { validate: false }).validate();
    }
    getL2Tx() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new L2Transaction(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getRawL2Block() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new RawL2Block(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getTxProof() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getKvStateProof() {
        const start = 16;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getBlockHashesProof() {
        const start = 20;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getContext() {
        const start = 24;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new VerifyTransactionContext(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
}
exports.VerifyTransactionWitness = VerifyTransactionWitness;
function SerializeVerifyTransactionWitness(value) {
    const buffers = [];
    buffers.push(SerializeL2Transaction(value.l2tx));
    buffers.push(SerializeRawL2Block(value.raw_l2block));
    buffers.push(SerializeBytes(value.tx_proof));
    buffers.push(SerializeBytes(value.kv_state_proof));
    buffers.push(SerializeBytes(value.block_hashes_proof));
    buffers.push(SerializeVerifyTransactionContext(value.context));
    return serializeTable(buffers);
}
exports.SerializeVerifyTransactionWitness = SerializeVerifyTransactionWitness;
class VerifyTransactionSignatureContext {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new KVPairVec(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new ScriptVec(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
    }
    getAccountCount() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getKvState() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new KVPairVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getScripts() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new ScriptVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.VerifyTransactionSignatureContext = VerifyTransactionSignatureContext;
function SerializeVerifyTransactionSignatureContext(value) {
    const buffers = [];
    buffers.push(SerializeUint32(value.account_count));
    buffers.push(SerializeKVPairVec(value.kv_state));
    buffers.push(SerializeScriptVec(value.scripts));
    return serializeTable(buffers);
}
exports.SerializeVerifyTransactionSignatureContext = SerializeVerifyTransactionSignatureContext;
class VerifyTransactionSignatureWitness {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new L2Transaction(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[3], offsets[4]), {
            validate: false,
        }).validate();
        new VerifyTransactionSignatureContext(this.view.buffer.slice(offsets[4], offsets[5]), { validate: false }).validate();
    }
    getRawL2Block() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new RawL2Block(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getL2Tx() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new L2Transaction(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getTxProof() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getKvStateProof() {
        const start = 16;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getContext() {
        const start = 20;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new VerifyTransactionSignatureContext(this.view.buffer.slice(offset, offset_end), { validate: false });
    }
}
exports.VerifyTransactionSignatureWitness = VerifyTransactionSignatureWitness;
function SerializeVerifyTransactionSignatureWitness(value) {
    const buffers = [];
    buffers.push(SerializeRawL2Block(value.raw_l2block));
    buffers.push(SerializeL2Transaction(value.l2tx));
    buffers.push(SerializeBytes(value.tx_proof));
    buffers.push(SerializeBytes(value.kv_state_proof));
    buffers.push(SerializeVerifyTransactionSignatureContext(value.context));
    return serializeTable(buffers);
}
exports.SerializeVerifyTransactionSignatureWitness = SerializeVerifyTransactionSignatureWitness;
class VerifyWithdrawalWitness {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new RawL2Block(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new WithdrawalRequest(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
    }
    getRawL2Block() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new RawL2Block(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getWithdrawalRequest() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new WithdrawalRequest(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getWithdrawalProof() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.VerifyWithdrawalWitness = VerifyWithdrawalWitness;
function SerializeVerifyWithdrawalWitness(value) {
    const buffers = [];
    buffers.push(SerializeRawL2Block(value.raw_l2block));
    buffers.push(SerializeWithdrawalRequest(value.withdrawal_request));
    buffers.push(SerializeBytes(value.withdrawal_proof));
    return serializeTable(buffers);
}
exports.SerializeVerifyWithdrawalWitness = SerializeVerifyWithdrawalWitness;
class RollupSubmitBlock {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new L2Block(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Byte32Vec(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
    }
    getBlock() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new L2Block(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getRevertedBlockHashes() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32Vec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getRevertedBlockProof() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.RollupSubmitBlock = RollupSubmitBlock;
function SerializeRollupSubmitBlock(value) {
    const buffers = [];
    buffers.push(SerializeL2Block(value.block));
    buffers.push(SerializeByte32Vec(value.reverted_block_hashes));
    buffers.push(SerializeBytes(value.reverted_block_proof));
    return serializeTable(buffers);
}
exports.SerializeRollupSubmitBlock = SerializeRollupSubmitBlock;
class RollupEnterChallenge {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new ChallengeWitness(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
    }
    getWitness() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new ChallengeWitness(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.RollupEnterChallenge = RollupEnterChallenge;
function SerializeRollupEnterChallenge(value) {
    const buffers = [];
    buffers.push(SerializeChallengeWitness(value.witness));
    return serializeTable(buffers);
}
exports.SerializeRollupEnterChallenge = SerializeRollupEnterChallenge;
class RollupCancelChallenge {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
    }
}
exports.RollupCancelChallenge = RollupCancelChallenge;
function SerializeRollupCancelChallenge(value) {
    const buffers = [];
    return serializeTable(buffers);
}
exports.SerializeRollupCancelChallenge = SerializeRollupCancelChallenge;
class RollupRevert {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new RawL2BlockVec(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
    }
    getRevertedBlocks() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new RawL2BlockVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getBlockProof() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getRevertedBlockProof() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.RollupRevert = RollupRevert;
function SerializeRollupRevert(value) {
    const buffers = [];
    buffers.push(SerializeRawL2BlockVec(value.reverted_blocks));
    buffers.push(SerializeBytes(value.block_proof));
    buffers.push(SerializeBytes(value.reverted_block_proof));
    return serializeTable(buffers);
}
exports.SerializeRollupRevert = SerializeRollupRevert;
class RollupAction {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        if (this.view.byteLength < 4) {
            assertDataLength(this.view.byteLength, ">4");
        }
        const t = this.view.getUint32(0, true);
        switch (t) {
            case 0:
                new RollupSubmitBlock(this.view.buffer.slice(4), {
                    validate: false,
                }).validate();
                break;
            case 1:
                new RollupEnterChallenge(this.view.buffer.slice(4), {
                    validate: false,
                }).validate();
                break;
            case 2:
                new RollupCancelChallenge(this.view.buffer.slice(4), {
                    validate: false,
                }).validate();
                break;
            case 3:
                new RollupRevert(this.view.buffer.slice(4), {
                    validate: false,
                }).validate();
                break;
            default:
                throw new Error(`Invalid type: ${t}`);
        }
    }
    unionType() {
        const t = this.view.getUint32(0, true);
        switch (t) {
            case 0:
                return "RollupSubmitBlock";
            case 1:
                return "RollupEnterChallenge";
            case 2:
                return "RollupCancelChallenge";
            case 3:
                return "RollupRevert";
            default:
                throw new Error(`Invalid type: ${t}`);
        }
    }
    value() {
        const t = this.view.getUint32(0, true);
        switch (t) {
            case 0:
                return new RollupSubmitBlock(this.view.buffer.slice(4), {
                    validate: false,
                });
            case 1:
                return new RollupEnterChallenge(this.view.buffer.slice(4), {
                    validate: false,
                });
            case 2:
                return new RollupCancelChallenge(this.view.buffer.slice(4), {
                    validate: false,
                });
            case 3:
                return new RollupRevert(this.view.buffer.slice(4), { validate: false });
            default:
                throw new Error(`Invalid type: ${t}`);
        }
    }
}
exports.RollupAction = RollupAction;
function SerializeRollupAction(value) {
    switch (value.type) {
        case "RollupSubmitBlock": {
            const itemBuffer = SerializeRollupSubmitBlock(value.value);
            const array = new Uint8Array(4 + itemBuffer.byteLength);
            const view = new DataView(array.buffer);
            view.setUint32(0, 0, true);
            array.set(new Uint8Array(itemBuffer), 4);
            return array.buffer;
        }
        case "RollupEnterChallenge": {
            const itemBuffer = SerializeRollupEnterChallenge(value.value);
            const array = new Uint8Array(4 + itemBuffer.byteLength);
            const view = new DataView(array.buffer);
            view.setUint32(0, 1, true);
            array.set(new Uint8Array(itemBuffer), 4);
            return array.buffer;
        }
        case "RollupCancelChallenge": {
            const itemBuffer = SerializeRollupCancelChallenge(value.value);
            const array = new Uint8Array(4 + itemBuffer.byteLength);
            const view = new DataView(array.buffer);
            view.setUint32(0, 2, true);
            array.set(new Uint8Array(itemBuffer), 4);
            return array.buffer;
        }
        case "RollupRevert": {
            const itemBuffer = SerializeRollupRevert(value.value);
            const array = new Uint8Array(4 + itemBuffer.byteLength);
            const view = new DataView(array.buffer);
            view.setUint32(0, 3, true);
            array.set(new Uint8Array(itemBuffer), 4);
            return array.buffer;
        }
        default:
            throw new Error(`Invalid type: ${value.type}`);
    }
}
exports.SerializeRollupAction = SerializeRollupAction;
class Uint16 {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, 2);
    }
    indexAt(i) {
        return this.view.getUint8(i);
    }
    raw() {
        return this.view.buffer;
    }
    toBigEndianUint16() {
        return this.view.getUint16(0, false);
    }
    toLittleEndianUint16() {
        return this.view.getUint16(0, true);
    }
    static size() {
        return 2;
    }
}
exports.Uint16 = Uint16;
function SerializeUint16(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 2);
    return buffer;
}
exports.SerializeUint16 = SerializeUint16;
class Uint32 {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, 4);
    }
    indexAt(i) {
        return this.view.getUint8(i);
    }
    raw() {
        return this.view.buffer;
    }
    toBigEndianUint32() {
        return this.view.getUint32(0, false);
    }
    toLittleEndianUint32() {
        return this.view.getUint32(0, true);
    }
    static size() {
        return 4;
    }
}
exports.Uint32 = Uint32;
function SerializeUint32(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 4);
    return buffer;
}
exports.SerializeUint32 = SerializeUint32;
class Uint64 {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, 8);
    }
    indexAt(i) {
        return this.view.getUint8(i);
    }
    raw() {
        return this.view.buffer;
    }
    toBigEndianBigUint64() {
        return this.view.getBigUint64(0, false);
    }
    toLittleEndianBigUint64() {
        return this.view.getUint64(0, true);
    }
    static size() {
        return 8;
    }
}
exports.Uint64 = Uint64;
function SerializeUint64(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 8);
    return buffer;
}
exports.SerializeUint64 = SerializeUint64;
class Uint128 {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, 16);
    }
    indexAt(i) {
        return this.view.getUint8(i);
    }
    raw() {
        return this.view.buffer;
    }
    static size() {
        return 16;
    }
}
exports.Uint128 = Uint128;
function SerializeUint128(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 16);
    return buffer;
}
exports.SerializeUint128 = SerializeUint128;
class Byte32 {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, 32);
    }
    indexAt(i) {
        return this.view.getUint8(i);
    }
    raw() {
        return this.view.buffer;
    }
    static size() {
        return 32;
    }
}
exports.Byte32 = Byte32;
function SerializeByte32(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 32);
    return buffer;
}
exports.SerializeByte32 = SerializeByte32;
class Uint256 {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, 32);
    }
    indexAt(i) {
        return this.view.getUint8(i);
    }
    raw() {
        return this.view.buffer;
    }
    static size() {
        return 32;
    }
}
exports.Uint256 = Uint256;
function SerializeUint256(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 32);
    return buffer;
}
exports.SerializeUint256 = SerializeUint256;
class Bytes {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        if (this.view.byteLength < 4) {
            dataLengthError(this.view.byteLength, ">4");
        }
        const requiredByteLength = this.length() + 4;
        assertDataLength(this.view.byteLength, requiredByteLength);
    }
    raw() {
        return this.view.buffer.slice(4);
    }
    indexAt(i) {
        return this.view.getUint8(4 + i);
    }
    length() {
        return this.view.getUint32(0, true);
    }
}
exports.Bytes = Bytes;
function SerializeBytes(value) {
    const item = assertArrayBuffer(value);
    const array = new Uint8Array(4 + item.byteLength);
    new DataView(array.buffer).setUint32(0, item.byteLength, true);
    array.set(new Uint8Array(item), 4);
    return array.buffer;
}
exports.SerializeBytes = SerializeBytes;
class BytesOpt {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        if (this.hasValue()) {
            this.value().validate(compatible);
        }
    }
    value() {
        return new Bytes(this.view.buffer, { validate: false });
    }
    hasValue() {
        return this.view.byteLength > 0;
    }
}
exports.BytesOpt = BytesOpt;
function SerializeBytesOpt(value) {
    if (value) {
        return SerializeBytes(value);
    }
    else {
        return new ArrayBuffer(0);
    }
}
exports.SerializeBytesOpt = SerializeBytesOpt;
class BytesVec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        for (let i = 0; i < len(offsets) - 1; i++) {
            new Bytes(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
                validate: false,
            }).validate();
        }
    }
    length() {
        if (this.view.byteLength < 8) {
            return 0;
        }
        else {
            return this.view.getUint32(4, true) / 4 - 1;
        }
    }
    indexAt(i) {
        const start = 4 + i * 4;
        const offset = this.view.getUint32(start, true);
        let offset_end = this.view.byteLength;
        if (i + 1 < this.length()) {
            offset_end = this.view.getUint32(start + 4, true);
        }
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.BytesVec = BytesVec;
function SerializeBytesVec(value) {
    return serializeTable(value.map((item) => SerializeBytes(item)));
}
exports.SerializeBytesVec = SerializeBytesVec;
class Byte32Vec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        if (this.view.byteLength < 4) {
            dataLengthError(this.view.byteLength, ">4");
        }
        const requiredByteLength = this.length() * Byte32.size() + 4;
        assertDataLength(this.view.byteLength, requiredByteLength);
        for (let i = 0; i < 0; i++) {
            const item = this.indexAt(i);
            item.validate(compatible);
        }
    }
    indexAt(i) {
        return new Byte32(this.view.buffer.slice(4 + i * Byte32.size(), 4 + (i + 1) * Byte32.size()), { validate: false });
    }
    length() {
        return this.view.getUint32(0, true);
    }
}
exports.Byte32Vec = Byte32Vec;
function SerializeByte32Vec(value) {
    const array = new Uint8Array(4 + Byte32.size() * value.length);
    new DataView(array.buffer).setUint32(0, value.length, true);
    for (let i = 0; i < value.length; i++) {
        const itemBuffer = SerializeByte32(value[i]);
        array.set(new Uint8Array(itemBuffer), 4 + i * Byte32.size());
    }
    return array.buffer;
}
exports.SerializeByte32Vec = SerializeByte32Vec;
class ScriptOpt {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        if (this.hasValue()) {
            this.value().validate(compatible);
        }
    }
    value() {
        return new Script(this.view.buffer, { validate: false });
    }
    hasValue() {
        return this.view.byteLength > 0;
    }
}
exports.ScriptOpt = ScriptOpt;
function SerializeScriptOpt(value) {
    if (value) {
        return SerializeScript(value);
    }
    else {
        return new ArrayBuffer(0);
    }
}
exports.SerializeScriptOpt = SerializeScriptOpt;
class ProposalShortId {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, 10);
    }
    indexAt(i) {
        return this.view.getUint8(i);
    }
    raw() {
        return this.view.buffer;
    }
    static size() {
        return 10;
    }
}
exports.ProposalShortId = ProposalShortId;
function SerializeProposalShortId(value) {
    const buffer = assertArrayBuffer(value);
    assertDataLength(buffer.byteLength, 10);
    return buffer;
}
exports.SerializeProposalShortId = SerializeProposalShortId;
class UncleBlockVec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        for (let i = 0; i < len(offsets) - 1; i++) {
            new UncleBlock(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
                validate: false,
            }).validate();
        }
    }
    length() {
        if (this.view.byteLength < 8) {
            return 0;
        }
        else {
            return this.view.getUint32(4, true) / 4 - 1;
        }
    }
    indexAt(i) {
        const start = 4 + i * 4;
        const offset = this.view.getUint32(start, true);
        let offset_end = this.view.byteLength;
        if (i + 1 < this.length()) {
            offset_end = this.view.getUint32(start + 4, true);
        }
        return new UncleBlock(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.UncleBlockVec = UncleBlockVec;
function SerializeUncleBlockVec(value) {
    return serializeTable(value.map((item) => SerializeUncleBlock(item)));
}
exports.SerializeUncleBlockVec = SerializeUncleBlockVec;
class TransactionVec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        for (let i = 0; i < len(offsets) - 1; i++) {
            new Transaction(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
                validate: false,
            }).validate();
        }
    }
    length() {
        if (this.view.byteLength < 8) {
            return 0;
        }
        else {
            return this.view.getUint32(4, true) / 4 - 1;
        }
    }
    indexAt(i) {
        const start = 4 + i * 4;
        const offset = this.view.getUint32(start, true);
        let offset_end = this.view.byteLength;
        if (i + 1 < this.length()) {
            offset_end = this.view.getUint32(start + 4, true);
        }
        return new Transaction(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.TransactionVec = TransactionVec;
function SerializeTransactionVec(value) {
    return serializeTable(value.map((item) => SerializeTransaction(item)));
}
exports.SerializeTransactionVec = SerializeTransactionVec;
class ProposalShortIdVec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        if (this.view.byteLength < 4) {
            dataLengthError(this.view.byteLength, ">4");
        }
        const requiredByteLength = this.length() * ProposalShortId.size() + 4;
        assertDataLength(this.view.byteLength, requiredByteLength);
        for (let i = 0; i < 0; i++) {
            const item = this.indexAt(i);
            item.validate(compatible);
        }
    }
    indexAt(i) {
        return new ProposalShortId(this.view.buffer.slice(4 + i * ProposalShortId.size(), 4 + (i + 1) * ProposalShortId.size()), { validate: false });
    }
    length() {
        return this.view.getUint32(0, true);
    }
}
exports.ProposalShortIdVec = ProposalShortIdVec;
function SerializeProposalShortIdVec(value) {
    const array = new Uint8Array(4 + ProposalShortId.size() * value.length);
    new DataView(array.buffer).setUint32(0, value.length, true);
    for (let i = 0; i < value.length; i++) {
        const itemBuffer = SerializeProposalShortId(value[i]);
        array.set(new Uint8Array(itemBuffer), 4 + i * ProposalShortId.size());
    }
    return array.buffer;
}
exports.SerializeProposalShortIdVec = SerializeProposalShortIdVec;
class CellDepVec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        if (this.view.byteLength < 4) {
            dataLengthError(this.view.byteLength, ">4");
        }
        const requiredByteLength = this.length() * CellDep.size() + 4;
        assertDataLength(this.view.byteLength, requiredByteLength);
        for (let i = 0; i < 0; i++) {
            const item = this.indexAt(i);
            item.validate(compatible);
        }
    }
    indexAt(i) {
        return new CellDep(this.view.buffer.slice(4 + i * CellDep.size(), 4 + (i + 1) * CellDep.size()), { validate: false });
    }
    length() {
        return this.view.getUint32(0, true);
    }
}
exports.CellDepVec = CellDepVec;
function SerializeCellDepVec(value) {
    const array = new Uint8Array(4 + CellDep.size() * value.length);
    new DataView(array.buffer).setUint32(0, value.length, true);
    for (let i = 0; i < value.length; i++) {
        const itemBuffer = SerializeCellDep(value[i]);
        array.set(new Uint8Array(itemBuffer), 4 + i * CellDep.size());
    }
    return array.buffer;
}
exports.SerializeCellDepVec = SerializeCellDepVec;
class CellInputVec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        if (this.view.byteLength < 4) {
            dataLengthError(this.view.byteLength, ">4");
        }
        const requiredByteLength = this.length() * CellInput.size() + 4;
        assertDataLength(this.view.byteLength, requiredByteLength);
        for (let i = 0; i < 0; i++) {
            const item = this.indexAt(i);
            item.validate(compatible);
        }
    }
    indexAt(i) {
        return new CellInput(this.view.buffer.slice(4 + i * CellInput.size(), 4 + (i + 1) * CellInput.size()), { validate: false });
    }
    length() {
        return this.view.getUint32(0, true);
    }
}
exports.CellInputVec = CellInputVec;
function SerializeCellInputVec(value) {
    const array = new Uint8Array(4 + CellInput.size() * value.length);
    new DataView(array.buffer).setUint32(0, value.length, true);
    for (let i = 0; i < value.length; i++) {
        const itemBuffer = SerializeCellInput(value[i]);
        array.set(new Uint8Array(itemBuffer), 4 + i * CellInput.size());
    }
    return array.buffer;
}
exports.SerializeCellInputVec = SerializeCellInputVec;
class CellOutputVec {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        for (let i = 0; i < len(offsets) - 1; i++) {
            new CellOutput(this.view.buffer.slice(offsets[i], offsets[i + 1]), {
                validate: false,
            }).validate();
        }
    }
    length() {
        if (this.view.byteLength < 8) {
            return 0;
        }
        else {
            return this.view.getUint32(4, true) / 4 - 1;
        }
    }
    indexAt(i) {
        const start = 4 + i * 4;
        const offset = this.view.getUint32(start, true);
        let offset_end = this.view.byteLength;
        if (i + 1 < this.length()) {
            offset_end = this.view.getUint32(start + 4, true);
        }
        return new CellOutput(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.CellOutputVec = CellOutputVec;
function SerializeCellOutputVec(value) {
    return serializeTable(value.map((item) => SerializeCellOutput(item)));
}
exports.SerializeCellOutputVec = SerializeCellOutputVec;
class Script {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Byte32(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        if (offsets[2] - offsets[1] !== 1) {
            throw new Error(`Invalid offset for hash_type: ${offsets[1]} - ${offsets[2]}`);
        }
        new Bytes(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
    }
    getCodeHash() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getHashType() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new DataView(this.view.buffer.slice(offset, offset_end)).getUint8(0);
    }
    getArgs() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.Script = Script;
function SerializeScript(value) {
    const buffers = [];
    buffers.push(SerializeByte32(value.code_hash));
    const hashTypeView = new DataView(new ArrayBuffer(1));
    hashTypeView.setUint8(0, value.hash_type);
    buffers.push(hashTypeView.buffer);
    buffers.push(SerializeBytes(value.args));
    return serializeTable(buffers);
}
exports.SerializeScript = SerializeScript;
class OutPoint {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getTxHash() {
        return new Byte32(this.view.buffer.slice(0, 0 + Byte32.size()), {
            validate: false,
        });
    }
    getIndex() {
        return new Uint32(this.view.buffer.slice(0 + Byte32.size(), 0 + Byte32.size() + Uint32.size()), { validate: false });
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, OutPoint.size());
        this.getTxHash().validate(compatible);
        this.getIndex().validate(compatible);
    }
    static size() {
        return 0 + Byte32.size() + Uint32.size();
    }
}
exports.OutPoint = OutPoint;
function SerializeOutPoint(value) {
    const array = new Uint8Array(0 + Byte32.size() + Uint32.size());
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeByte32(value.tx_hash)), 0);
    array.set(new Uint8Array(SerializeUint32(value.index)), 0 + Byte32.size());
    return array.buffer;
}
exports.SerializeOutPoint = SerializeOutPoint;
class CellInput {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getSince() {
        return new Uint64(this.view.buffer.slice(0, 0 + Uint64.size()), {
            validate: false,
        });
    }
    getPreviousOutput() {
        return new OutPoint(this.view.buffer.slice(0 + Uint64.size(), 0 + Uint64.size() + OutPoint.size()), { validate: false });
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, CellInput.size());
        this.getSince().validate(compatible);
        this.getPreviousOutput().validate(compatible);
    }
    static size() {
        return 0 + Uint64.size() + OutPoint.size();
    }
}
exports.CellInput = CellInput;
function SerializeCellInput(value) {
    const array = new Uint8Array(0 + Uint64.size() + OutPoint.size());
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeUint64(value.since)), 0);
    array.set(new Uint8Array(SerializeOutPoint(value.previous_output)), 0 + Uint64.size());
    return array.buffer;
}
exports.SerializeCellInput = SerializeCellInput;
class CellOutput {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Uint64(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Script(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new ScriptOpt(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
    }
    getCapacity() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint64(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getLock() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Script(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getType() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new ScriptOpt(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.CellOutput = CellOutput;
function SerializeCellOutput(value) {
    const buffers = [];
    buffers.push(SerializeUint64(value.capacity));
    buffers.push(SerializeScript(value.lock));
    buffers.push(SerializeScriptOpt(value.type_));
    return serializeTable(buffers);
}
exports.SerializeCellOutput = SerializeCellOutput;
class CellDep {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getOutPoint() {
        return new OutPoint(this.view.buffer.slice(0, 0 + OutPoint.size()), {
            validate: false,
        });
    }
    getDepType() {
        return this.view.getUint8(0 + OutPoint.size());
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, CellDep.size());
        this.getOutPoint().validate(compatible);
    }
    static size() {
        return 0 + OutPoint.size() + 1;
    }
}
exports.CellDep = CellDep;
function SerializeCellDep(value) {
    const array = new Uint8Array(0 + OutPoint.size() + 1);
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeOutPoint(value.out_point)), 0);
    view.setUint8(0 + OutPoint.size(), value.dep_type);
    return array.buffer;
}
exports.SerializeCellDep = SerializeCellDep;
class RawTransaction {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Uint32(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new CellDepVec(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new Byte32Vec(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
        new CellInputVec(this.view.buffer.slice(offsets[3], offsets[4]), {
            validate: false,
        }).validate();
        new CellOutputVec(this.view.buffer.slice(offsets[4], offsets[5]), {
            validate: false,
        }).validate();
        new BytesVec(this.view.buffer.slice(offsets[5], offsets[6]), {
            validate: false,
        }).validate();
    }
    getVersion() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Uint32(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getCellDeps() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new CellDepVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getHeaderDeps() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Byte32Vec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getInputs() {
        const start = 16;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new CellInputVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getOutputs() {
        const start = 20;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new CellOutputVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getOutputsData() {
        const start = 24;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new BytesVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.RawTransaction = RawTransaction;
function SerializeRawTransaction(value) {
    const buffers = [];
    buffers.push(SerializeUint32(value.version));
    buffers.push(SerializeCellDepVec(value.cell_deps));
    buffers.push(SerializeByte32Vec(value.header_deps));
    buffers.push(SerializeCellInputVec(value.inputs));
    buffers.push(SerializeCellOutputVec(value.outputs));
    buffers.push(SerializeBytesVec(value.outputs_data));
    return serializeTable(buffers);
}
exports.SerializeRawTransaction = SerializeRawTransaction;
class Transaction {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new RawTransaction(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new BytesVec(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
    }
    getRaw() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new RawTransaction(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getWitnesses() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new BytesVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.Transaction = Transaction;
function SerializeTransaction(value) {
    const buffers = [];
    buffers.push(SerializeRawTransaction(value.raw));
    buffers.push(SerializeBytesVec(value.witnesses));
    return serializeTable(buffers);
}
exports.SerializeTransaction = SerializeTransaction;
class RawHeader {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getVersion() {
        return new Uint32(this.view.buffer.slice(0, 0 + Uint32.size()), {
            validate: false,
        });
    }
    getCompactTarget() {
        return new Uint32(this.view.buffer.slice(0 + Uint32.size(), 0 + Uint32.size() + Uint32.size()), { validate: false });
    }
    getTimestamp() {
        return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size()), { validate: false });
    }
    getNumber() {
        return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size(), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size()), { validate: false });
    }
    getEpoch() {
        return new Uint64(this.view.buffer.slice(0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size(), 0 +
            Uint32.size() +
            Uint32.size() +
            Uint64.size() +
            Uint64.size() +
            Uint64.size()), { validate: false });
    }
    getParentHash() {
        return new Byte32(this.view.buffer.slice(0 +
            Uint32.size() +
            Uint32.size() +
            Uint64.size() +
            Uint64.size() +
            Uint64.size(), 0 +
            Uint32.size() +
            Uint32.size() +
            Uint64.size() +
            Uint64.size() +
            Uint64.size() +
            Byte32.size()), { validate: false });
    }
    getTransactionsRoot() {
        return new Byte32(this.view.buffer.slice(0 +
            Uint32.size() +
            Uint32.size() +
            Uint64.size() +
            Uint64.size() +
            Uint64.size() +
            Byte32.size(), 0 +
            Uint32.size() +
            Uint32.size() +
            Uint64.size() +
            Uint64.size() +
            Uint64.size() +
            Byte32.size() +
            Byte32.size()), { validate: false });
    }
    getProposalsHash() {
        return new Byte32(this.view.buffer.slice(0 +
            Uint32.size() +
            Uint32.size() +
            Uint64.size() +
            Uint64.size() +
            Uint64.size() +
            Byte32.size() +
            Byte32.size(), 0 +
            Uint32.size() +
            Uint32.size() +
            Uint64.size() +
            Uint64.size() +
            Uint64.size() +
            Byte32.size() +
            Byte32.size() +
            Byte32.size()), { validate: false });
    }
    getUnclesHash() {
        return new Byte32(this.view.buffer.slice(0 +
            Uint32.size() +
            Uint32.size() +
            Uint64.size() +
            Uint64.size() +
            Uint64.size() +
            Byte32.size() +
            Byte32.size() +
            Byte32.size(), 0 +
            Uint32.size() +
            Uint32.size() +
            Uint64.size() +
            Uint64.size() +
            Uint64.size() +
            Byte32.size() +
            Byte32.size() +
            Byte32.size() +
            Byte32.size()), { validate: false });
    }
    getDao() {
        return new Byte32(this.view.buffer.slice(0 +
            Uint32.size() +
            Uint32.size() +
            Uint64.size() +
            Uint64.size() +
            Uint64.size() +
            Byte32.size() +
            Byte32.size() +
            Byte32.size() +
            Byte32.size(), 0 +
            Uint32.size() +
            Uint32.size() +
            Uint64.size() +
            Uint64.size() +
            Uint64.size() +
            Byte32.size() +
            Byte32.size() +
            Byte32.size() +
            Byte32.size() +
            Byte32.size()), { validate: false });
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, RawHeader.size());
        this.getVersion().validate(compatible);
        this.getCompactTarget().validate(compatible);
        this.getTimestamp().validate(compatible);
        this.getNumber().validate(compatible);
        this.getEpoch().validate(compatible);
        this.getParentHash().validate(compatible);
        this.getTransactionsRoot().validate(compatible);
        this.getProposalsHash().validate(compatible);
        this.getUnclesHash().validate(compatible);
        this.getDao().validate(compatible);
    }
    static size() {
        return (0 +
            Uint32.size() +
            Uint32.size() +
            Uint64.size() +
            Uint64.size() +
            Uint64.size() +
            Byte32.size() +
            Byte32.size() +
            Byte32.size() +
            Byte32.size() +
            Byte32.size());
    }
}
exports.RawHeader = RawHeader;
function SerializeRawHeader(value) {
    const array = new Uint8Array(0 +
        Uint32.size() +
        Uint32.size() +
        Uint64.size() +
        Uint64.size() +
        Uint64.size() +
        Byte32.size() +
        Byte32.size() +
        Byte32.size() +
        Byte32.size() +
        Byte32.size());
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeUint32(value.version)), 0);
    array.set(new Uint8Array(SerializeUint32(value.compact_target)), 0 + Uint32.size());
    array.set(new Uint8Array(SerializeUint64(value.timestamp)), 0 + Uint32.size() + Uint32.size());
    array.set(new Uint8Array(SerializeUint64(value.number)), 0 + Uint32.size() + Uint32.size() + Uint64.size());
    array.set(new Uint8Array(SerializeUint64(value.epoch)), 0 + Uint32.size() + Uint32.size() + Uint64.size() + Uint64.size());
    array.set(new Uint8Array(SerializeByte32(value.parent_hash)), 0 +
        Uint32.size() +
        Uint32.size() +
        Uint64.size() +
        Uint64.size() +
        Uint64.size());
    array.set(new Uint8Array(SerializeByte32(value.transactions_root)), 0 +
        Uint32.size() +
        Uint32.size() +
        Uint64.size() +
        Uint64.size() +
        Uint64.size() +
        Byte32.size());
    array.set(new Uint8Array(SerializeByte32(value.proposals_hash)), 0 +
        Uint32.size() +
        Uint32.size() +
        Uint64.size() +
        Uint64.size() +
        Uint64.size() +
        Byte32.size() +
        Byte32.size());
    array.set(new Uint8Array(SerializeByte32(value.uncles_hash)), 0 +
        Uint32.size() +
        Uint32.size() +
        Uint64.size() +
        Uint64.size() +
        Uint64.size() +
        Byte32.size() +
        Byte32.size() +
        Byte32.size());
    array.set(new Uint8Array(SerializeByte32(value.dao)), 0 +
        Uint32.size() +
        Uint32.size() +
        Uint64.size() +
        Uint64.size() +
        Uint64.size() +
        Byte32.size() +
        Byte32.size() +
        Byte32.size() +
        Byte32.size());
    return array.buffer;
}
exports.SerializeRawHeader = SerializeRawHeader;
class Header {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    getRaw() {
        return new RawHeader(this.view.buffer.slice(0, 0 + RawHeader.size()), {
            validate: false,
        });
    }
    getNonce() {
        return new Uint128(this.view.buffer.slice(0 + RawHeader.size(), 0 + RawHeader.size() + Uint128.size()), { validate: false });
    }
    validate(compatible = false) {
        assertDataLength(this.view.byteLength, Header.size());
        this.getRaw().validate(compatible);
        this.getNonce().validate(compatible);
    }
    static size() {
        return 0 + RawHeader.size() + Uint128.size();
    }
}
exports.Header = Header;
function SerializeHeader(value) {
    const array = new Uint8Array(0 + RawHeader.size() + Uint128.size());
    const view = new DataView(array.buffer);
    array.set(new Uint8Array(SerializeRawHeader(value.raw)), 0);
    array.set(new Uint8Array(SerializeUint128(value.nonce)), 0 + RawHeader.size());
    return array.buffer;
}
exports.SerializeHeader = SerializeHeader;
class UncleBlock {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Header(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new ProposalShortIdVec(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
    }
    getHeader() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Header(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getProposals() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.UncleBlock = UncleBlock;
function SerializeUncleBlock(value) {
    const buffers = [];
    buffers.push(SerializeHeader(value.header));
    buffers.push(SerializeProposalShortIdVec(value.proposals));
    return serializeTable(buffers);
}
exports.SerializeUncleBlock = SerializeUncleBlock;
class Block {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Header(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new UncleBlockVec(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new TransactionVec(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
        new ProposalShortIdVec(this.view.buffer.slice(offsets[3], offsets[4]), {
            validate: false,
        }).validate();
    }
    getHeader() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Header(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getUncles() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new UncleBlockVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getTransactions() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new TransactionVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getProposals() {
        const start = 16;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new ProposalShortIdVec(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.Block = Block;
function SerializeBlock(value) {
    const buffers = [];
    buffers.push(SerializeHeader(value.header));
    buffers.push(SerializeUncleBlockVec(value.uncles));
    buffers.push(SerializeTransactionVec(value.transactions));
    buffers.push(SerializeProposalShortIdVec(value.proposals));
    return serializeTable(buffers);
}
exports.SerializeBlock = SerializeBlock;
class CellbaseWitness {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new Script(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new Bytes(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
    }
    getLock() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new Script(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getMessage() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new Bytes(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.CellbaseWitness = CellbaseWitness;
function SerializeCellbaseWitness(value) {
    const buffers = [];
    buffers.push(SerializeScript(value.lock));
    buffers.push(SerializeBytes(value.message));
    return serializeTable(buffers);
}
exports.SerializeCellbaseWitness = SerializeCellbaseWitness;
class WitnessArgs {
    constructor(reader, { validate = true } = {}) {
        this.view = new DataView(assertArrayBuffer(reader));
        if (validate) {
            this.validate();
        }
    }
    validate(compatible = false) {
        const offsets = verifyAndExtractOffsets(this.view, 0, true);
        new BytesOpt(this.view.buffer.slice(offsets[0], offsets[1]), {
            validate: false,
        }).validate();
        new BytesOpt(this.view.buffer.slice(offsets[1], offsets[2]), {
            validate: false,
        }).validate();
        new BytesOpt(this.view.buffer.slice(offsets[2], offsets[3]), {
            validate: false,
        }).validate();
    }
    getLock() {
        const start = 4;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new BytesOpt(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getInputType() {
        const start = 8;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.getUint32(start + 4, true);
        return new BytesOpt(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
    getOutputType() {
        const start = 12;
        const offset = this.view.getUint32(start, true);
        const offset_end = this.view.byteLength;
        return new BytesOpt(this.view.buffer.slice(offset, offset_end), {
            validate: false,
        });
    }
}
exports.WitnessArgs = WitnessArgs;
function SerializeWitnessArgs(value) {
    const buffers = [];
    buffers.push(SerializeBytesOpt(value.lock));
    buffers.push(SerializeBytesOpt(value.input_type));
    buffers.push(SerializeBytesOpt(value.output_type));
    return serializeTable(buffers);
}
exports.SerializeWitnessArgs = SerializeWitnessArgs;


/***/ }),

/***/ 303:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * this file is a custom http provider used to proxy ETH rpc call to godwoken-polyjuice chain.
 * it is fork and based on https://github.com/ChainSafe/web3.js/tree/1.x/packages/web3-providers-http
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const http = __importStar(__webpack_require__(605));
const https = __importStar(__webpack_require__(211));
const web3_core_helpers_1 = __webpack_require__(653);
const xhr2_cookies_1 = __webpack_require__(159);
const util_1 = __webpack_require__(378);
const signer_1 = __importDefault(__webpack_require__(957));
const abi_1 = __webpack_require__(923);
class PolyjuiceHttpProvider {
    constructor(host, godwoken_config, abi_items = [], options) {
        this.signer = new signer_1.default();
        this.godwoker = new util_1.Godwoker(host, godwoken_config);
        this.abi = new abi_1.Abi(abi_items);
        options = options || {};
        this.withCredentials = options.withCredentials || false;
        this.timeout = options.timeout || 0;
        this.headers = options.headers;
        this.agent = options.agent;
        this.connected = false;
        // keepAlive is true unless explicitly set to false
        const keepAlive = options.keepAlive !== false;
        this.host = host || "http://localhost:8024";
        if (!this.agent) {
            if (this.host.substring(0, 5) === "https") {
                this.httpsAgent = new https.Agent({ keepAlive });
            }
            else {
                this.httpAgent = new http.Agent({ keepAlive });
            }
        }
    }
    async send(payload, callback) {
        const { method, params } = payload;
        switch (method) {
            case "eth_sendTransaction":
                try {
                    const { from, gas, gasPrice, value, data, to } = params[0];
                    const data_with_short_address = await this.abi.refactor_data_with_short_address(data, this.godwoker.getShortAddressByAllTypeEthAddress.bind(this.godwoker));
                    const t = {
                        from: from,
                        to: to,
                        value: value || 0,
                        data: data_with_short_address || "",
                        gas: gas,
                        gasPrice: gasPrice,
                    };
                    const to_id = await this.godwoker.allTypeEthAddressToAccountId(to);
                    const sender_script_hash = this.godwoker.computeScriptHashByEoaEthAddress(from);
                    const receiver_script_hash = await this.godwoker.getScriptHashByAccountId(parseInt(to_id));
                    const polyjuice_tx = await this.godwoker.assembleRawL2Transaction(t);
                    const message = this.godwoker.generateTransactionMessageToSign(polyjuice_tx, sender_script_hash, receiver_script_hash);
                    const _signature = await this.signer.sign_with_metamask(message, from);
                    const signature = this.godwoker.packSignature(_signature);
                    const tx_hash = await this.godwoker.gw_submitL2Transaction(polyjuice_tx, signature);
                    await this.godwoker.waitForTransactionReceipt(tx_hash);
                    this._send(payload, function (err, result) {
                        const res = {
                            jsonrpc: result.jsonrpc,
                            id: result.id,
                        };
                        const new_res = { ...res, ...{ result: tx_hash } };
                        callback(null, new_res);
                    });
                    break;
                }
                catch (error) {
                    this.connected = false;
                    throw error;
                }
            case "eth_call":
                try {
                    const { from, gas, gasPrice, value, data, to } = params[0];
                    const data_with_short_address = await this.abi.refactor_data_with_short_address(data, this.godwoker.getShortAddressByAllTypeEthAddress.bind(this.godwoker));
                    const t = {
                        from: from || "0x" + "0".repeat(40),
                        to: to,
                        value: value || 0,
                        data: data_with_short_address || "",
                        gas: gas || 5000000,
                        gasPrice: gasPrice || 0,
                    };
                    const polyjuice_tx = await this.godwoker.assembleRawL2Transaction(t);
                    const run_result = await this.godwoker.gw_executeRawL2Transaction(polyjuice_tx);
                    const abi_item = this.abi.get_intereted_abi_item_by_encoded_data(data);
                    if (!abi_item) {
                        this._send(payload, function (err, result) {
                            const res = {
                                jsonrpc: result.jsonrpc,
                                id: result.id,
                            };
                            const new_res = { ...res, ...{ result: run_result.return_data } };
                            callback(null, new_res);
                        });
                    }
                    else {
                        const return_value_with_short_address = await this.abi.refactor_return_value_with_short_address(run_result.return_data, abi_item, this.godwoker.getEthAddressByAllTypeShortAddress.bind(this.godwoker));
                        this._send(payload, function (err, result) {
                            const res = {
                                jsonrpc: result.jsonrpc,
                                id: result.id,
                            };
                            const new_res = {
                                ...res,
                                ...{ result: return_value_with_short_address },
                            };
                            callback(null, new_res);
                        });
                    }
                    break;
                }
                catch (error) {
                    this.connected = false;
                    throw error;
                }
            case "eth_estimateGas":
                try {
                    var new_payload = payload;
                    const { data } = params[0];
                    const data_with_short_address = await this.abi.refactor_data_with_short_address(data, this.godwoker.getShortAddressByAllTypeEthAddress.bind(this.godwoker));
                    new_payload.params[0].data = data_with_short_address;
                    this._send(new_payload, callback);
                    break;
                }
                catch (error) {
                    this.connected = false;
                    throw error;
                }
            default:
                try {
                    this._send(payload, callback);
                    break;
                }
                catch (error) {
                    this.connected = false;
                    throw error;
                }
        }
    }
    _prepareRequest() {
        var request;
        // the current runtime is a browser
        if (typeof XMLHttpRequest !== "undefined") {
            request = new XMLHttpRequest();
        }
        else {
            request = new xhr2_cookies_1.XMLHttpRequest();
            var agents = {
                httpsAgent: this.httpsAgent,
                httpAgent: this.httpAgent,
                baseUrl: this.baseUrl,
            };
            if (this.agent) {
                agents.httpsAgent = this.agent.https;
                agents.httpAgent = this.agent.http;
                agents.baseUrl = this.agent.baseUrl;
            }
            request.nodejsSet(agents);
        }
        request.open("POST", this.host, true);
        request.setRequestHeader("Content-Type", "application/json");
        request.timeout = this.timeout;
        request.withCredentials = this.withCredentials;
        if (this.headers) {
            this.headers.forEach(function (header) {
                request.setRequestHeader(header.name, header.value);
            });
        }
        return request;
    }
    /**
     * Should be used to make async request
     *
     * @method send
     * @param {Object} payload
     * @param {Function} callback triggered on end with (err, result)
     */
    _send(payload, callback) {
        var _this = this;
        var request = this._prepareRequest();
        request.onreadystatechange = function () {
            if (request.readyState === 4 && request.timeout !== 1) {
                var result = request.responseText;
                var error = null;
                try {
                    result = JSON.parse(result);
                }
                catch (e) {
                    error = web3_core_helpers_1.errors.InvalidResponse(request.responseText);
                }
                _this.connected = true;
                callback(error, result);
            }
        };
        request.ontimeout = function () {
            _this.connected = false;
            callback(web3_core_helpers_1.errors.ConnectionTimeout(this.timeout));
        };
        try {
            request.send(JSON.stringify(payload));
        }
        catch (error) {
            this.connected = false;
            callback(web3_core_helpers_1.errors.InvalidConnection(this.host));
        }
    }
    /**
     * Returns the desired boolean.
     *
     * @method supportsSubscriptions
     * @returns {boolean}
     */
    supportsSubscriptions() {
        return false;
    }
    disconnect() {
        return this.connected;
    }
}
exports.default = PolyjuiceHttpProvider;


/***/ }),

/***/ 957:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var Buffer = __webpack_require__(293)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
const eth_sig_util_1 = __webpack_require__(458);
class Signer {
    constructor(private_key) {
        this.private_key = private_key;
    }
    // message without prefix "\x19Ethereum Signed Message:\n"
    async sign_with_metamask(message_without_prefix, address) {
        if (!window.ethereum) {
            alert("please install metamask!");
            throw new Error("metamask not found. if you are in nodejs env, you can try sign_with_private_key method.");
        }
        const _signature = await window.ethereum.request({
            method: "personal_sign",
            params: [message_without_prefix, address],
        });
        return _signature;
    }
    // message without prefix "\x19Ethereum Signed Message:\n"
    sign_with_private_key(message_without_prefix, address) {
        if (!this.private_key) {
            throw new Error("private key not found! cannot use this method!");
        }
        let privateKeyBuffer = Buffer.from(this.private_key.length === 40
            ? this.private_key
            : this.private_key.slice(2), "hex");
        const signature = eth_sig_util_1.personalSign(privateKeyBuffer, {
            data: message_without_prefix,
        });
        return signature;
    }
}
exports.default = Signer;


/***/ }),

/***/ 378:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/* provided dependency */ var fetch = __webpack_require__(762);
/* provided dependency */ var Buffer = __webpack_require__(293)["Buffer"];

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Godwoker = void 0;
const base_1 = __webpack_require__(916);
const godwoken_1 = __webpack_require__(445);
const schemas_1 = __webpack_require__(243);
const normalizer_1 = __webpack_require__(197);
const ckb_js_toolkit_1 = __webpack_require__(683);
const jaysonBrowserClient = __webpack_require__(709);
const U128_MIN = BigInt(0);
const U128_MAX = BigInt(2) ** BigInt(128) - BigInt(1);
const EMPTY_ETH_ADDRESS = "0x" + "00".repeat(20);
class Godwoker {
    constructor(host, option) {
        const callServer = function (request, callback) {
            const opt = option.request_option || {
                method: "POST",
                body: request,
                headers: {
                    "Content-Type": "application/json",
                },
            };
            fetch(host, opt)
                .then(function (res) {
                return res.text();
            })
                .then(function (text) {
                callback(null, text);
            })
                .catch(function (err) {
                callback(err);
            });
        };
        this.client = jaysonBrowserClient(callServer);
        this.godwkenUtils = new godwoken_1.GodwokenUtils(option.godwoken.rollup_type_hash);
        this.eth_account_lock = option.godwoken.eth_account_lock;
        this.rollup_type_hash = option.godwoken.rollup_type_hash;
        this.queryEthAddressByShortAddress = option.queryEthAddressByShortAddress;
        this.saveEthAddressShortAddressMapping =
            option.saveEthAddressShortAddressMapping;
    }
    packSignature(_signature) {
        let v = Number.parseInt(_signature.slice(-2), 16);
        if (v >= 27)
            v -= 27;
        const signature = _signature.slice(0, -2) + v.toString(16).padStart(2, "0");
        return signature;
    }
    computeScriptHashByEoaEthAddress(eth_address) {
        const layer2_lock = {
            code_hash: this.eth_account_lock.code_hash,
            hash_type: this.eth_account_lock.hash_type,
            args: this.rollup_type_hash + eth_address.slice(2),
        };
        const lock_hash = base_1.utils.computeScriptHash(layer2_lock);
        return lock_hash;
    }
    async getScriptByScriptHash(_script_hash) {
        return new Promise((resolve, reject) => {
            this.client.request("gw_get_script", [_script_hash], (err, res) => {
                if (err)
                    return reject(err);
                if (!res || res.result === undefined || res.result === null)
                    return reject(new Error(`unable to fetch script from ${_script_hash}`));
                return resolve(res.result);
            });
        });
    }
    async getScriptHashByAccountId(account_id) {
        return new Promise((resolve, reject) => {
            this.client.request("gw_get_script_hash", [`0x${BigInt(account_id).toString(16)}`], (err, res) => {
                if (err)
                    return reject(err);
                if (!res || res.result === undefined || res.result === null)
                    return reject(new Error(`unable to fetch account script hash from 0x${BigInt(account_id).toString(16)}`));
                return resolve(res.result);
            });
        });
    }
    async getAccountIdByScriptHash(script_hash) {
        return new Promise((resolve, reject) => {
            this.client.request("gw_get_account_id_by_script_hash", [script_hash], (err, res) => {
                if (err)
                    return reject(err);
                if (!res || res.result === undefined || res.result === null)
                    return reject(new Error(`unable to fetch account id from script hash ${script_hash}`));
                return resolve(res.result);
            });
        });
    }
    async getAccountIdByEoaEthAddress(eth_address) {
        const layer2_lock = {
            code_hash: this.eth_account_lock.code_hash,
            hash_type: this.eth_account_lock.hash_type,
            args: this.rollup_type_hash + eth_address.slice(2),
        };
        const lock_hash = base_1.utils.computeScriptHash(layer2_lock);
        return new Promise((resolve, reject) => {
            this.client.request("gw_get_account_id_by_script_hash", [lock_hash], (err, res) => {
                if (err)
                    return reject(err);
                if (!res || res.result === undefined || res.result === null)
                    return reject(new Error(`unable to fetch account id from ${eth_address}, lock_hash is ${lock_hash}`));
                return resolve(res.result);
            });
        });
    }
    async getScriptHashByShortAddress(_address) {
        return new Promise((resolve, reject) => {
            this.client.request("gw_get_script_hash_by_short_address", [_address], (err, res) => {
                if (err)
                    return reject(err);
                if (!res || !res || res.result === undefined || res.result === null)
                    return reject(new Error(`unable to fetch script hash from short address: ${_address}`));
                return resolve(res.result);
            });
        });
    }
    computeShortAddressByEoaEthAddress(_address, write_callback) {
        const short_address = this.computeScriptHashByEoaEthAddress(_address).slice(0, 42);
        if (write_callback) {
            write_callback(_address, short_address);
        }
        return short_address;
    }
    async getShortAddressByAllTypeEthAddress(_address) {
        // todo: support create2 address in such case that it haven't create real contract yet.
        try {
            // assume it is an contract address (thus already an short address)
            await this.getScriptHashByShortAddress(_address);
            return _address;
        }
        catch (error) {
            // script hash not exist with short address, assume it is EOA address..
            // remember to save the script and eoa address mapping with default or user-specific callback
            const write_callback = this.saveEthAddressShortAddressMapping
                ? this.saveEthAddressShortAddressMapping
                : this.defaultSaveEthAddressShortAddressMapping.bind(this);
            return this.computeShortAddressByEoaEthAddress(_address, write_callback);
        }
    }
    async getEthAddressByAllTypeShortAddress(_short_address) {
        // todo: support create2 address in such case which it haven't create real contract yet.
        try {
            // first, query on-chain
            const script_hash = await this.getScriptHashByShortAddress(_short_address);
            const script = await this.getScriptByScriptHash(script_hash);
            if (script.code_hash === this.eth_account_lock.code_hash) {
                return "0x" + script.args.slice(66, 106);
            }
            // assume it is normal contract address.
            return _short_address;
        }
        catch (error) {
            // not on-chain, asume it is  eoa address
            // which haven't create account on godwoken yet
            const query_callback = this.queryEthAddressByShortAddress
                ? this.queryEthAddressByShortAddress
                : this.defaultQueryEthAddressByShortAddress.bind(this);
            const eth_address = await query_callback(_short_address);
            // check address and short_address indeed matched.
            if (this.checkEthAddressIsEoa(eth_address, _short_address)) {
                return eth_address;
            }
            else {
                throw Error(`query result of eoa address ${_short_address} with ${_short_address} is not match!`);
            }
        }
    }
    // re-compute the eth address with code_hash info to make sure
    // it indeed match with short_address
    checkEthAddressIsEoa(eth_address, _target_short_address) {
        const source_short_address = this.computeShortAddressByEoaEthAddress(eth_address);
        console.log(source_short_address, _target_short_address);
        return (source_short_address.toLowerCase() === _target_short_address.toLowerCase());
    }
    // default method
    async defaultQueryEthAddressByShortAddress(_short_address) {
        return new Promise((resolve, reject) => {
            this.client.request("poly_getEthAddressByGodwokenShortAddress", [_short_address], (err, res) => {
                if (err)
                    return reject(err);
                if (!res || res.result === undefined || res.result === null)
                    return reject(new Error(`unable to fetch eth address from ${_short_address}`));
                return resolve(res.result);
            });
        });
    }
    // default method
    async defaultSaveEthAddressShortAddressMapping(_eth_address, _short_address) {
        return new Promise((resolve, reject) => {
            this.client.request("poly_saveEthAddressGodwokenShortAddressMapping", [_eth_address, _short_address], (err, res) => {
                if (err)
                    return reject(err);
                if (!res || res.result !== "ok")
                    return reject(new Error(`unable to save eth address and short address in web3 server.`));
                return resolve(res.result);
            });
        });
    }
    async getNonce(account_id) {
        return new Promise((resolve, reject) => {
            this.client.request("gw_get_nonce", [`0x${account_id.toString(16)}`], (err, res) => {
                if (err)
                    return reject(err);
                if (!res || res.result === undefined || res.result === null)
                    return reject(new Error(`unable to fetch nonce, account_id:${account_id}, ${JSON.stringify(res)}`));
                return resolve(res.result);
            });
        });
    }
    async assembleRawL2Transaction(eth_tx) {
        const from = await this.getAccountIdByEoaEthAddress(eth_tx.from);
        const to = await this.allTypeEthAddressToAccountId(eth_tx.to);
        const nonce = await this.getNonce(parseInt(from));
        const encodedArgs = this.encodeArgs(eth_tx);
        const tx = {
            from_id: "0x" + BigInt(from).toString(16),
            to_id: "0x" + BigInt(to).toString(16),
            args: encodedArgs,
            nonce: "0x" + BigInt(nonce).toString(16),
        };
        return tx;
    }
    generateTransactionMessageToSign(tx, sender_script_hash, receiver_script_hash, is_add_prefix_in_signing_message = false) {
        return this.godwkenUtils.generateTransactionMessageToSign(tx, sender_script_hash, receiver_script_hash, is_add_prefix_in_signing_message);
    }
    async generateMessageFromEthTransaction(tx) {
        const { from, to } = tx;
        const to_id = await this.allTypeEthAddressToAccountId(to);
        const sender_script_hash = this.computeScriptHashByEoaEthAddress(from);
        const receiver_script_hash = await this.getScriptHashByAccountId(parseInt(to_id));
        const polyjuice_tx = await this.assembleRawL2Transaction(tx);
        const message = this.generateTransactionMessageToSign(polyjuice_tx, sender_script_hash, receiver_script_hash, true // with personal sign prefixed
        );
        return message;
    }
    serializeL2Transaction(tx) {
        const _tx = normalizer_1.NormalizeL2Transaction(tx);
        return new ckb_js_toolkit_1.Reader(schemas_1.SerializeL2Transaction(_tx)).serializeJson();
    }
    serializeRawL2Transaction(tx) {
        const _tx = normalizer_1.NormalizeRawL2Transaction(tx);
        return new ckb_js_toolkit_1.Reader(schemas_1.SerializeRawL2Transaction(_tx)).serializeJson();
    }
    async gw_executeL2Tranaction(raw_tx, signature) {
        const l2_tx = { raw: raw_tx, signature: signature };
        const serialize_tx = this.serializeL2Transaction(l2_tx);
        return new Promise((resolve, reject) => {
            this.client.request("gw_execute_l2_tranaction", [serialize_tx], (err, res) => {
                if (err)
                    return reject(err);
                if (!res || res.result === undefined || res.result === null)
                    return reject(new Error(`failed to send gw_executeL2Tranaction rpc, ${JSON.stringify(res)}`));
                return resolve(res.result);
            });
        });
    }
    async gw_executeRawL2Transaction(raw_tx) {
        const serialize_tx = this.serializeRawL2Transaction(raw_tx);
        return new Promise((resolve, reject) => {
            this.client.request("gw_execute_raw_l2transaction", [serialize_tx], (err, res) => {
                if (err)
                    return reject(err);
                if (!res || res.result === undefined || res.result === null)
                    return reject(new Error(`failed to send gw_executeRawL2Tranaction rpc, ${JSON.stringify(res)}`));
                return resolve(res.result);
            });
        });
    }
    async gw_submitL2Transaction(raw_tx, signature) {
        const l2_tx = { raw: raw_tx, signature: signature };
        const serialize_tx = this.serializeL2Transaction(l2_tx);
        return new Promise((resolve, reject) => {
            this.client.request("gw_submit_l2transaction", [serialize_tx], (err, res) => {
                if (err)
                    return reject(err);
                if (!res || res.result === undefined || res.result === null)
                    return reject(new Error(`failed to send gw_submitL2Transaction rpc, ${JSON.stringify(res)}`));
                return resolve(res.result);
            });
        });
    }
    async gw_getTransactionReceipt(tx_hash) {
        return new Promise((resolve, reject) => {
            this.client.request("gw_get_transaction_receipt", [tx_hash], (err, res) => {
                if (err)
                    return reject(err);
                //if(!res || res.result === undefined || res.result === null) resolve( Error(`failed to send gw_getTransactionReceipt rpc, ${JSON.stringify(res)}`);
                return resolve(res.result);
            });
        });
    }
    async eth_getTransactionReceipt(tx_hash) {
        return new Promise((resolve, reject) => {
            this.client.request("eth_getTransactionReceipt", [tx_hash], (err, res) => {
                if (err)
                    return reject(err);
                //if(!res || res.result === undefined || res.result === null) resolve( Error(`failed to send gw_getTransactionReceipt rpc, ${JSON.stringify(res)}`);
                return resolve(res.result);
            });
        });
    }
    async waitForTransactionReceipt(tx_hash) {
        while (true) {
            await this.asyncSleep(3000);
            const tx_receipt = await this.eth_getTransactionReceipt(tx_hash);
            console.log(`keep waitting for tx_receipt..`);
            if (tx_receipt) {
                break;
            }
        }
        return;
    }
    asyncSleep(ms = 0) {
        return new Promise((r) => setTimeout(r, ms));
    }
    async allTypeEthAddressToAccountId(_address) {
        // todo: support create2 address in such case that it haven't create real contract yet.
        const address = Buffer.from(_address.slice(2), "hex");
        if (address.byteLength !== 20)
            throw new Error(`Invalid eth address length: ${address.byteLength}`);
        if (address.equals(Buffer.from(Array(20).fill(0))))
            // special-case: meta-contract address should return creator
            return "0x3";
        try {
            // assume it is normal contract address, thus an godwoken-short-address
            const script_hash = await this.getScriptHashByShortAddress(_address);
            return await this.getAccountIdByScriptHash(script_hash);
        }
        catch (error) {
            if (!JSON.stringify(error).includes("unable to fetch script hash from short address"))
                throw error;
            // otherwise, assume it is EOA address
            const script_hash = this.computeScriptHashByEoaEthAddress(_address);
            const accountId = await this.getAccountIdByScriptHash(script_hash);
            return accountId;
        }
    }
    encodeArgs(_tx) {
        const { to, gasPrice, gas: gasLimit, value, data } = _tx;
        // header
        const args_0_7 = "0x" +
            Buffer.from("FFFFFF", "hex").toString("hex") +
            Buffer.from("POLY", "utf8").toString("hex");
        // gas limit
        const args_8_16 = this.UInt64ToLeBytes(BigInt(gasLimit));
        // gas price
        const args_16_32 = this.UInt128ToLeBytes(gasPrice === "0x" ? BigInt(0) : BigInt(gasPrice));
        // value
        const args_32_48 = this.UInt128ToLeBytes(value === "0x" ? BigInt(0) : BigInt(value));
        const dataByteLength = Buffer.from(data.slice(2), "hex").length;
        // data length
        const args_48_52 = this.UInt32ToLeBytes(dataByteLength);
        // data
        const args_data = data;
        let args_7 = "";
        if (to === EMPTY_ETH_ADDRESS || to === "0x" || to === "0x0") {
            args_7 = "0x03";
        }
        else {
            args_7 = "0x00";
        }
        const args = "0x" +
            args_0_7.slice(2) +
            args_7.slice(2) +
            args_8_16.slice(2) +
            args_16_32.slice(2) +
            args_32_48.slice(2) +
            args_48_52.slice(2) +
            args_data.slice(2);
        return args;
    }
    // todo: move to another file
    UInt32ToLeBytes(num) {
        const buf = Buffer.allocUnsafe(4);
        buf.writeUInt32LE(+num, 0);
        return "0x" + buf.toString("hex");
    }
    UInt64ToLeBytes(num) {
        num = BigInt(num);
        const buf = Buffer.alloc(8);
        buf.writeBigUInt64LE(num);
        return `0x${buf.toString("hex")}`;
    }
    UInt128ToLeBytes(u128) {
        if (u128 < U128_MIN) {
            throw new Error(`u128 ${u128} too small`);
        }
        if (u128 > U128_MAX) {
            throw new Error(`u128 ${u128} too large`);
        }
        const buf = Buffer.alloc(16);
        buf.writeBigUInt64LE(u128 & BigInt("0xFFFFFFFFFFFFFFFF"), 0);
        buf.writeBigUInt64LE(u128 >> BigInt(64), 8);
        return "0x" + buf.toString("hex");
    }
    LeBytesToUInt32(hex) {
        const buf = Buffer.from(hex.slice(2), "hex");
        return buf.readUInt32LE();
    }
}
exports.Godwoker = Godwoker;


/***/ }),

/***/ 916:
/***/ ((module) => {

"use strict";
module.exports = require("@ckb-lumos/base");;

/***/ }),

/***/ 293:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");;

/***/ }),

/***/ 683:
/***/ ((module) => {

"use strict";
module.exports = require("ckb-js-toolkit");;

/***/ }),

/***/ 762:
/***/ ((module) => {

"use strict";
module.exports = require("cross-fetch");;

/***/ }),

/***/ 458:
/***/ ((module) => {

"use strict";
module.exports = require("eth-sig-util");;

/***/ }),

/***/ 605:
/***/ ((module) => {

"use strict";
module.exports = require("http");;

/***/ }),

/***/ 211:
/***/ ((module) => {

"use strict";
module.exports = require("https");;

/***/ }),

/***/ 709:
/***/ ((module) => {

"use strict";
module.exports = require("jayson/lib/client/browser");;

/***/ }),

/***/ 715:
/***/ ((module) => {

"use strict";
module.exports = require("keccak256");;

/***/ }),

/***/ 653:
/***/ ((module) => {

"use strict";
module.exports = require("web3-core-helpers");;

/***/ }),

/***/ 107:
/***/ ((module) => {

"use strict";
module.exports = require("web3-eth-abi");;

/***/ }),

/***/ 159:
/***/ ((module) => {

"use strict";
module.exports = require("xhr2-cookies");;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__(971);
/******/ 	__webpack_exports__ = __webpack_exports__.default;
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});
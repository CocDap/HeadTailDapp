"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withdraw = exports.prepareSigningEntries = exports.injectCapacity = exports.setupOutputCell = exports.checkLimit = exports.setupInputCell = exports.CellCollector = void 0;
const base_1 = require("@ckb-lumos/base");
const config_manager_1 = require("@ckb-lumos/config-manager");
const helpers_1 = require("@ckb-lumos/helpers");
const ckb_js_toolkit_1 = require("ckb-js-toolkit");
const immutable_1 = require("immutable");
const from_info_1 = require("./from_info");
const helper_1 = require("./helper");
const { ScriptValue } = base_1.values;
const { CKBHasher, ckbHash, readBigUInt128LE } = base_1.utils;
class CellCollector {
    constructor(fromInfo, cellProvider, { config = undefined, queryOptions = {}, } = {}) {
        if (!cellProvider) {
            throw new Error(`Cell provider is missing!`);
        }
        config = config || config_manager_1.getConfig();
        this.fromScript = from_info_1.parseFromInfo(fromInfo, { config }).fromScript;
        this.config = config;
        queryOptions = {
            ...queryOptions,
            lock: this.fromScript,
            type: queryOptions.type || "empty",
        };
        this.cellCollector = cellProvider.collector(queryOptions);
    }
    async *collect() {
        if (!helper_1.isAcpScript(this.fromScript, this.config)) {
            return;
        }
        for await (const inputCell of this.cellCollector.collect()) {
            yield inputCell;
        }
    }
}
exports.CellCollector = CellCollector;
async function setupInputCell(txSkeleton, inputCell, _fromInfo, { config = undefined, defaultWitness = "0x", since = undefined, } = {}) {
    config = config || config_manager_1.getConfig();
    const inputLock = inputCell.cell_output.lock;
    if (!helper_1.isAcpScript(inputLock, config)) {
        throw new Error("Not anyone-can-pay input!");
    }
    // add inputCell to txSkeleton
    txSkeleton = txSkeleton.update("inputs", (inputs) => {
        return inputs.push(inputCell);
    });
    if (since) {
        txSkeleton = txSkeleton.update("inputSinces", (inputSinces) => {
            return inputSinces.set(txSkeleton.get("inputs").size - 1, since);
        });
    }
    txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
        return witnesses.push(defaultWitness);
    });
    const outputCell = {
        cell_output: {
            capacity: inputCell.cell_output.capacity,
            lock: inputCell.cell_output.lock,
            type: inputCell.cell_output.type,
        },
        data: inputCell.data,
    };
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.push(outputCell);
    });
    txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
        return fixedEntries.push({
            field: "outputs",
            index: txSkeleton.get("outputs").size - 1,
        });
    });
    const template = config.SCRIPTS.ANYONE_CAN_PAY;
    if (!template) {
        throw new Error(`ANYONE_CAN_PAY script not defined in config!`);
    }
    const scriptOutPoint = {
        tx_hash: template.TX_HASH,
        index: template.INDEX,
    };
    // add cell_dep
    txSkeleton = helper_1.addCellDep(txSkeleton, {
        out_point: scriptOutPoint,
        dep_type: template.DEP_TYPE,
    });
    // add witness
    const firstIndex = txSkeleton.get("inputs").findIndex((input) => {
        return new ScriptValue(input.cell_output.lock, { validate: false }).equals(new ScriptValue(inputLock, { validate: false }));
    });
    if (firstIndex !== -1) {
        while (firstIndex >= txSkeleton.get("witnesses").size) {
            txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
                return witnesses.push("0x");
            });
        }
        let witness = txSkeleton.get("witnesses").get(firstIndex);
        const newWitnessArgs = {
            /* 65-byte zeros in hex */
            lock: helper_1.SECP_SIGNATURE_PLACEHOLDER,
        };
        if (witness !== "0x") {
            const witnessArgs = new base_1.core.WitnessArgs(new ckb_js_toolkit_1.Reader(witness));
            const lock = witnessArgs.getLock();
            if (lock.hasValue() &&
                new ckb_js_toolkit_1.Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock) {
                throw new Error("Lock field in first witness is set aside for signature!");
            }
            const inputType = witnessArgs.getInputType();
            if (inputType.hasValue()) {
                newWitnessArgs.input_type = new ckb_js_toolkit_1.Reader(inputType.value().raw()).serializeJson();
            }
            const outputType = witnessArgs.getOutputType();
            if (outputType.hasValue()) {
                newWitnessArgs.output_type = new ckb_js_toolkit_1.Reader(outputType.value().raw()).serializeJson();
            }
        }
        witness = new ckb_js_toolkit_1.Reader(base_1.core.SerializeWitnessArgs(ckb_js_toolkit_1.normalizers.NormalizeWitnessArgs(newWitnessArgs))).serializeJson();
        txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
            return witnesses.set(firstIndex, witness);
        });
    }
    return txSkeleton;
}
exports.setupInputCell = setupInputCell;
// export for tests
function checkLimit(acpArgs, capacity) {
    let minimalAmount;
    let minimalCapacity;
    if (acpArgs.length >= 46) {
        minimalAmount = 10n ** BigInt("0x" + acpArgs.slice(44, 46));
    }
    if (acpArgs.length >= 44) {
        // should convert to shannons
        minimalCapacity = 10n ** BigInt("0x" + acpArgs.slice(42, 44)) * 10n ** 8n;
    }
    // Both minimalAmount & minimalCapacity OR only minimalCapacity
    if (minimalCapacity && minimalAmount) {
        if (capacity < minimalCapacity) {
            throw new Error(`capacity(${capacity}) less than toAddress minimal capacity limit(${minimalCapacity}), and amount less then toAddress minimal amount limit(${minimalAmount})! If you want to transfer sudt, maybe sudt.transfer can help you.`);
        }
    }
    else if (minimalCapacity) {
        if (capacity < minimalCapacity) {
            throw new Error(`capacity(${capacity}) less than toAddress minimal capacity limit(${minimalCapacity})!`);
        }
    }
}
exports.checkLimit = checkLimit;
async function setupOutputCell(txSkeleton, outputCell, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    const toScript = outputCell.cell_output.lock;
    const capacity = BigInt(outputCell.cell_output.capacity);
    checkLimit(toScript.args, capacity);
    const cellProvider = txSkeleton.get("cellProvider");
    if (!cellProvider) {
        throw new Error(`Cell Provider is missing!`);
    }
    const toAddress = helpers_1.generateAddress(toScript, { config });
    const toAddressCellCollector = new CellCollector(toAddress, cellProvider, {
        config,
    });
    const toAddressInput = (await toAddressCellCollector.collect().next()).value;
    let outputCapacity = capacity;
    if (toAddressInput) {
        outputCapacity = capacity + BigInt(toAddressInput.cell_output.capacity);
        txSkeleton = txSkeleton.update("inputs", (inputs) => {
            return inputs.push(toAddressInput);
        });
        txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
            return witnesses.push("0x");
        });
    }
    outputCell.cell_output.capacity = "0x" + outputCapacity.toString(16);
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.push(outputCell);
    });
    if (toAddressInput) {
        const template = config.SCRIPTS.ANYONE_CAN_PAY;
        if (!template) {
            throw new Error(`ANYONE_CAN_PAY script not defined in config!`);
        }
        const scriptOutPoint = {
            tx_hash: template.TX_HASH,
            index: template.INDEX,
        };
        // add cell_dep
        txSkeleton = helper_1.addCellDep(txSkeleton, {
            out_point: scriptOutPoint,
            dep_type: template.DEP_TYPE,
        });
    }
    return txSkeleton;
}
exports.setupOutputCell = setupOutputCell;
async function injectCapacity(cellCollector, txSkeleton, outputIndex, capacity, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    if (outputIndex >= txSkeleton.get("outputs").size) {
        throw new Error(`Invalid output index!`);
    }
    capacity = BigInt(capacity);
    const template = config.SCRIPTS.ANYONE_CAN_PAY;
    if (!template) {
        throw new Error(`Provided config does not have ANYONE_CAN_PAY script setup!`);
    }
    const fromScript = cellCollector.fromScript;
    /*
     * First, check if there is any output cells that contains enough capacity
     * for us to tinker with.
     *
     * TODO: the solution right now won't cover all cases, some outputs before the
     * last output might still be tinkerable, right now we are working on the
     * simple solution, later we can change this for more optimizations.
     */
    const lastFreezedOutput = txSkeleton
        .get("fixedEntries")
        .filter(({ field }) => field === "outputs")
        .maxBy(({ index }) => index);
    let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;
    for (; i < txSkeleton.get("outputs").size && capacity > 0; i++) {
        const output = txSkeleton.get("outputs").get(i);
        if (new ScriptValue(output.cell_output.lock, { validate: false }).equals(new ScriptValue(fromScript, { validate: false }))) {
            const cellCapacity = BigInt(output.cell_output.capacity);
            const availableCapacity = cellCapacity - helpers_1.minimalCellCapacity(output);
            // should maintain minimal cell capcity in anyone-can-pay output
            const deductCapacity = capacity >= availableCapacity ? availableCapacity : capacity;
            capacity -= deductCapacity;
            output.cell_output.capacity =
                "0x" + (cellCapacity - deductCapacity).toString(16);
        }
    }
    // Remove all output cells with capacity equal to 0
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.filter((output) => BigInt(output.cell_output.capacity) !== BigInt(0));
    });
    const getInputKey = (input) => `${input.out_point.tx_hash}_${input.out_point.index}`;
    if (capacity > 0n) {
        const changeCell = {
            cell_output: {
                capacity: "0x0",
                lock: fromScript,
                type: undefined,
            },
            data: "0x",
            out_point: undefined,
            block_hash: undefined,
        };
        let changeCapacity = 0n;
        const minimalChangeCapacity = helpers_1.minimalCellCapacity(changeCell);
        let previousInputs = immutable_1.Set();
        for (const input of txSkeleton.get("inputs")) {
            previousInputs = previousInputs.add(getInputKey(input));
        }
        // Are all from same lock script and type script, so only need one change cell
        for await (const inputCell of cellCollector.collect()) {
            if (previousInputs.has(getInputKey(inputCell))) {
                continue;
            }
            txSkeleton = await setupInputCell(txSkeleton, inputCell, undefined, {
                config,
            });
            const lastOutputIndex = txSkeleton.get("outputs").size - 1;
            txSkeleton = txSkeleton.update("outputs", (outputs) => {
                return outputs.remove(lastOutputIndex);
            });
            const fixedEntryIndex = txSkeleton
                .get("fixedEntries")
                .findIndex((fixedEntry) => {
                return (fixedEntry.field === "outputs" &&
                    fixedEntry.index === lastOutputIndex);
            });
            if (fixedEntryIndex >= 0) {
                txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
                    return fixedEntries.remove(fixedEntryIndex);
                });
            }
            const inputCapacity = BigInt(inputCell.cell_output.capacity);
            let deductCapacity = inputCapacity;
            if (deductCapacity > capacity) {
                deductCapacity = capacity;
            }
            capacity -= deductCapacity;
            changeCapacity += inputCapacity - deductCapacity;
            if (capacity === 0n && changeCapacity >= minimalChangeCapacity) {
                break;
            }
            changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
            txSkeleton = txSkeleton.update("outputs", (outputs) => {
                return outputs.push(changeCell);
            });
        }
        if (capacity > 0n || changeCapacity < minimalChangeCapacity) {
            throw new Error(`Not enough capacity in from address!`);
        }
        changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
        txSkeleton = txSkeleton.update("outputs", (outputs) => {
            return outputs.push(changeCell);
        });
    }
    return txSkeleton;
}
exports.injectCapacity = injectCapacity;
function prepareSigningEntries(txSkeleton, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    const scriptType = "ANYONE_CAN_PAY";
    const template = config.SCRIPTS[scriptType];
    if (!template) {
        throw new Error(`Provided config does not have ${scriptType} script setup!`);
    }
    let processedArgs = immutable_1.Set();
    const tx = helpers_1.createTransactionFromSkeleton(txSkeleton);
    const txHash = ckbHash(base_1.core.SerializeRawTransaction(ckb_js_toolkit_1.normalizers.NormalizeRawTransaction(tx))).serializeJson();
    const inputs = txSkeleton.get("inputs");
    const witnesses = txSkeleton.get("witnesses");
    let signingEntries = txSkeleton.get("signingEntries");
    for (let i = 0; i < inputs.size; i++) {
        const input = inputs.get(i);
        if (template.CODE_HASH === input.cell_output.lock.code_hash &&
            template.HASH_TYPE === input.cell_output.lock.hash_type &&
            !processedArgs.has(input.cell_output.lock.args)) {
            processedArgs = processedArgs.add(input.cell_output.lock.args);
            // skip if input sum capcity <= output sum capacity
            // and input sum amount <= output sum amount
            const outputs = txSkeleton.get("outputs").filter((output) => {
                return new ScriptValue(output.cell_output.lock, {
                    validate: false,
                }).equals(new ScriptValue(input.cell_output.lock, { validate: false }));
            });
            const sumOfOutputCapacity = outputs
                .map((output) => BigInt(output.cell_output.capacity))
                .reduce((result, c) => result + c, 0n);
            const sumOfOutputAmount = outputs
                .filter((output) => output.data !== "0x")
                .map((output) => readBigUInt128LE(output.data))
                .reduce((result, c) => result + c, 0n);
            const fInputs = inputs.filter((i) => {
                return new ScriptValue(i.cell_output.lock, { validate: false }).equals(new ScriptValue(input.cell_output.lock, { validate: false }));
            });
            const sumOfInputCapacity = fInputs
                .map((i) => BigInt(i.cell_output.capacity))
                .reduce((result, c) => result + c, 0n);
            const sumOfInputAmount = fInputs
                .filter((i) => i.data !== "0x")
                .map((i) => readBigUInt128LE(i.data))
                .reduce((result, c) => result + c, 0n);
            if (sumOfInputCapacity <= sumOfOutputCapacity &&
                sumOfInputAmount <= sumOfOutputAmount) {
                continue;
            }
            const lockValue = new base_1.values.ScriptValue(input.cell_output.lock, {
                validate: false,
            });
            const hasher = new CKBHasher();
            hasher.update(txHash);
            if (i >= witnesses.size) {
                throw new Error(`The first witness in the script group starting at input index ${i} does not exist, maybe some other part has invalidly tampered the transaction?`);
            }
            helper_1.hashWitness(hasher, witnesses.get(i));
            for (let j = i + 1; j < inputs.size && j < witnesses.size; j++) {
                const otherInput = inputs.get(j);
                if (lockValue.equals(new base_1.values.ScriptValue(otherInput.cell_output.lock, {
                    validate: false,
                }))) {
                    helper_1.hashWitness(hasher, witnesses.get(j));
                }
            }
            for (let j = inputs.size; j < witnesses.size; j++) {
                helper_1.hashWitness(hasher, witnesses.get(j));
            }
            const signingEntry = {
                type: "witness_args_lock",
                index: i,
                message: hasher.digestHex(),
            };
            signingEntries = signingEntries.push(signingEntry);
        }
    }
    txSkeleton = txSkeleton.set("signingEntries", signingEntries);
    return txSkeleton;
}
exports.prepareSigningEntries = prepareSigningEntries;
async function withdraw(txSkeleton, fromInput, toAddress, capacity, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    // from input must be a anyone-can-pay script
    if (!helper_1.isAcpScript(fromInput.cell_output.lock, config)) {
        throw new Error(`fromInput is not a ANYONE_CAN_PAY cell!`);
    }
    // check capacity
    capacity = BigInt(capacity);
    const fromInputCapacity = BigInt(fromInput.cell_output.capacity);
    const inputMinimalCellCapacity = helpers_1.minimalCellCapacity(fromInput);
    if (!((capacity >= 0n &&
        capacity <= fromInputCapacity - inputMinimalCellCapacity) ||
        capacity === fromInputCapacity)) {
        throw new Error(`capacity must be in [0, ${fromInputCapacity - inputMinimalCellCapacity}] or ${fromInputCapacity} !`);
    }
    const toScript = helpers_1.parseAddress(toAddress, { config });
    const targetOutput = {
        cell_output: {
            capacity: "0x" + capacity.toString(16),
            lock: toScript,
            type: undefined,
        },
        data: "0x",
        out_point: undefined,
        block_hash: undefined,
    };
    if (helper_1.isAcpScript(toScript, config)) {
        checkLimit(toScript.args, capacity);
        const cellProvider = txSkeleton.get("cellProvider");
        if (!cellProvider) {
            throw new Error(`Cell Provider is missing!`);
        }
        const toAddressCellCollector = new CellCollector(toAddress, cellProvider, {
            config,
        });
        const toAddressInput = (await toAddressCellCollector.collect().next()).value;
        if (!toAddressInput) {
            throw new Error(`toAddress ANYONE_CAN_PAY input not found!`);
        }
        const outputCapacity = BigInt(capacity) + BigInt(toAddressInput.cell_output.capacity);
        targetOutput.cell_output.capacity = "0x" + outputCapacity.toString(16);
        txSkeleton = txSkeleton.update("inputs", (inputs) => {
            return inputs.push(toAddressInput);
        });
        txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
            return witnesses.push("0x");
        });
    }
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.push(targetOutput);
    });
    txSkeleton = await setupInputCell(txSkeleton, fromInput, helpers_1.generateAddress(fromInput.cell_output.lock, { config }), { config });
    // remove output and fixedEntry added by `setupInputCell`
    const lastOutputIndex = txSkeleton.get("outputs").size - 1;
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.remove(lastOutputIndex);
    });
    const fixedEntryIndex = txSkeleton
        .get("fixedEntries")
        .findIndex((fixedEntry) => {
        return (fixedEntry.field === "outputs" && fixedEntry.index === lastOutputIndex);
    });
    if (fixedEntryIndex >= 0) {
        txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
            return fixedEntries.remove(fixedEntryIndex);
        });
    }
    if (capacity !== fromInputCapacity) {
        txSkeleton = txSkeleton.update("outputs", (outputs) => {
            return outputs.push({
                cell_output: {
                    capacity: "0x" + (fromInputCapacity - capacity).toString(16),
                    lock: fromInput.cell_output.lock,
                    type: fromInput.cell_output.type,
                },
                data: fromInput.data,
            });
        });
    }
    return txSkeleton;
}
exports.withdraw = withdraw;
exports.default = {
    CellCollector,
    setupInputCell,
    setupOutputCell,
    injectCapacity,
    prepareSigningEntries,
    withdraw,
};
//# sourceMappingURL=anyone_can_pay.js.map
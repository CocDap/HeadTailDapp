"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareSigningEntries = exports.injectCapacity = exports.payFee = exports.transfer = exports.setupInputCell = exports.CellCollector = void 0;
const immutable_1 = require("immutable");
const ckb_js_toolkit_1 = require("ckb-js-toolkit");
const helpers_1 = require("@ckb-lumos/helpers");
const base_1 = require("@ckb-lumos/base");
const config_manager_1 = require("@ckb-lumos/config-manager");
const helper_1 = require("./helper");
const from_info_1 = require("./from_info");
const { ScriptValue } = base_1.values;
class CellCollector {
    constructor(fromInfo, cellProvider, { config = undefined, queryOptions = {}, } = {}) {
        if (!cellProvider) {
            throw new Error(`Cell provider is missing!`);
        }
        config = config || config_manager_1.getConfig();
        this.fromScript = from_info_1.parseFromInfo(fromInfo, { config }).fromScript;
        this.config = config;
        queryOptions = {
            ...queryOptions,
            lock: this.fromScript,
            type: queryOptions.type || "empty",
        };
        this.cellCollector = cellProvider.collector(queryOptions);
    }
    async *collect() {
        if (!helper_1.isSecp256k1Blake160Script(this.fromScript, this.config)) {
            return;
        }
        for await (const inputCell of this.cellCollector.collect()) {
            yield inputCell;
        }
    }
}
exports.CellCollector = CellCollector;
/**
 * Setup input cell infos, such as cell deps and witnesses.
 *
 * @param txSkeleton
 * @param inputCell
 * @param options
 */
async function setupInputCell(txSkeleton, inputCell, _fromInfo, { config = undefined, defaultWitness = "0x", since = undefined, } = {}) {
    config = config || config_manager_1.getConfig();
    const fromScript = inputCell.cell_output.lock;
    if (!helper_1.isSecp256k1Blake160Script(fromScript, config)) {
        throw new Error(`Not SECP256K1_BLAKE160 input!`);
    }
    // add inputCell to txSkeleton
    txSkeleton = txSkeleton.update("inputs", (inputs) => {
        return inputs.push(inputCell);
    });
    const output = {
        cell_output: {
            capacity: inputCell.cell_output.capacity,
            lock: inputCell.cell_output.lock,
            type: inputCell.cell_output.type,
        },
        data: inputCell.data,
    };
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.push(output);
    });
    if (since) {
        txSkeleton = txSkeleton.update("inputSinces", (inputSinces) => {
            return inputSinces.set(txSkeleton.get("inputs").size - 1, since);
        });
    }
    txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
        return witnesses.push(defaultWitness);
    });
    const template = config.SCRIPTS.SECP256K1_BLAKE160;
    if (!template) {
        throw new Error(`SECP256K1_BLAKE160 script not defined in config!`);
    }
    const scriptOutPoint = {
        tx_hash: template.TX_HASH,
        index: template.INDEX,
    };
    // add cell dep
    txSkeleton = helper_1.addCellDep(txSkeleton, {
        out_point: scriptOutPoint,
        dep_type: template.DEP_TYPE,
    });
    // add witness
    /*
     * Modify the skeleton, so the first witness of the fromAddress script group
     * has a WitnessArgs construct with 65-byte zero filled values. While this
     * is not required, it helps in transaction fee estimation.
     */
    const firstIndex = txSkeleton
        .get("inputs")
        .findIndex((input) => new ScriptValue(input.cell_output.lock, { validate: false }).equals(new ScriptValue(fromScript, { validate: false })));
    if (firstIndex !== -1) {
        while (firstIndex >= txSkeleton.get("witnesses").size) {
            txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.push("0x"));
        }
        let witness = txSkeleton.get("witnesses").get(firstIndex);
        const newWitnessArgs = {
            /* 65-byte zeros in hex */
            lock: helper_1.SECP_SIGNATURE_PLACEHOLDER,
        };
        if (witness !== "0x") {
            const witnessArgs = new base_1.core.WitnessArgs(new ckb_js_toolkit_1.Reader(witness));
            const lock = witnessArgs.getLock();
            if (lock.hasValue() &&
                new ckb_js_toolkit_1.Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock) {
                throw new Error("Lock field in first witness is set aside for signature!");
            }
            const inputType = witnessArgs.getInputType();
            if (inputType.hasValue()) {
                newWitnessArgs.input_type = new ckb_js_toolkit_1.Reader(inputType.value().raw()).serializeJson();
            }
            const outputType = witnessArgs.getOutputType();
            if (outputType.hasValue()) {
                newWitnessArgs.output_type = new ckb_js_toolkit_1.Reader(outputType.value().raw()).serializeJson();
            }
        }
        witness = new ckb_js_toolkit_1.Reader(base_1.core.SerializeWitnessArgs(ckb_js_toolkit_1.normalizers.NormalizeWitnessArgs(newWitnessArgs))).serializeJson();
        txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.set(firstIndex, witness));
    }
    return txSkeleton;
}
exports.setupInputCell = setupInputCell;
/**
 * transfer capacity from secp256k1_blake160 script cells
 *
 * @param txSkeleton
 * @param fromAddress
 * @param toAddress
 * @param amount
 * @param options
 */
async function transfer(txSkeleton, fromAddress, toAddress, amount, { config = undefined, requireToAddress = true, assertAmountEnough = true, } = {}) {
    config = config || config_manager_1.getConfig();
    const template = config.SCRIPTS.SECP256K1_BLAKE160;
    if (!template) {
        throw new Error("Provided config does not have SECP256K1_BLAKE160 script setup!");
    }
    const scriptOutPoint = {
        tx_hash: template.TX_HASH,
        index: template.INDEX,
    };
    txSkeleton = helper_1.addCellDep(txSkeleton, {
        out_point: scriptOutPoint,
        dep_type: template.DEP_TYPE,
    });
    const fromScript = helpers_1.parseAddress(fromAddress, { config });
    helper_1.ensureScript(fromScript, config, "SECP256K1_BLAKE160");
    if (requireToAddress && !toAddress) {
        throw new Error("You must provide a to address!");
    }
    amount = BigInt(amount);
    if (toAddress) {
        const toScript = helpers_1.parseAddress(toAddress, { config });
        txSkeleton = txSkeleton.update("outputs", (outputs) => {
            return outputs.push({
                cell_output: {
                    capacity: "0x" + amount.toString(16),
                    lock: toScript,
                    type: undefined,
                },
                data: "0x",
                out_point: undefined,
                block_hash: undefined,
            });
        });
    }
    /*
     * First, check if there is any output cells that contains enough capacity
     * for us to tinker with.
     *
     * TODO: the solution right now won't cover all cases, some outputs before the
     * last output might still be tinkerable, right now we are working on the
     * simple solution, later we can change this for more optimizations.
     */
    const lastFreezedOutput = txSkeleton
        .get("fixedEntries")
        .filter(({ field }) => field === "outputs")
        .maxBy(({ index }) => index);
    let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;
    for (; i < txSkeleton.get("outputs").size && amount > 0; i++) {
        const output = txSkeleton.get("outputs").get(i);
        if (new ScriptValue(output.cell_output.lock, { validate: false }).equals(new ScriptValue(fromScript, { validate: false }))) {
            const cellCapacity = BigInt(output.cell_output.capacity);
            let deductCapacity;
            if (amount >= cellCapacity) {
                deductCapacity = cellCapacity;
            }
            else {
                deductCapacity = cellCapacity - helpers_1.minimalCellCapacity(output);
                if (deductCapacity > amount) {
                    deductCapacity = amount;
                }
            }
            amount -= deductCapacity;
            output.cell_output.capacity =
                "0x" + (cellCapacity - deductCapacity).toString(16);
        }
    }
    // Remove all output cells with capacity equal to 0
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.filter((output) => BigInt(output.cell_output.capacity) !== BigInt(0));
    });
    /*
     * Collect and add new input cells so as to prepare remaining capacities.
     */
    if (amount > 0) {
        const cellProvider = txSkeleton.get("cellProvider");
        if (!cellProvider) {
            throw new Error("Cell provider is missing!");
        }
        const cellCollector = cellProvider.collector({
            lock: fromScript,
        });
        const changeCell = {
            cell_output: {
                capacity: "0x0",
                lock: fromScript,
                type: undefined,
            },
            data: "0x",
            out_point: undefined,
            block_hash: undefined,
        };
        let changeCapacity = BigInt(0);
        let previousInputs = immutable_1.Set();
        for (const input of txSkeleton.get("inputs")) {
            previousInputs = previousInputs.add(`${input.out_point.tx_hash}_${input.out_point.index}`);
        }
        for await (const inputCell of cellCollector.collect()) {
            // skip inputs already exists in txSkeleton.inputs
            if (previousInputs.has(`${inputCell.out_point.tx_hash}_${inputCell.out_point.index}`)) {
                continue;
            }
            txSkeleton = txSkeleton.update("inputs", (inputs) => inputs.push(inputCell));
            txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.push("0x"));
            const inputCapacity = BigInt(inputCell.cell_output.capacity);
            let deductCapacity = inputCapacity;
            if (deductCapacity > amount) {
                deductCapacity = amount;
            }
            amount -= deductCapacity;
            changeCapacity += inputCapacity - deductCapacity;
            if (amount === BigInt(0) &&
                (changeCapacity === BigInt(0) ||
                    changeCapacity > helpers_1.minimalCellCapacity(changeCell))) {
                break;
            }
        }
        if (changeCapacity > BigInt(0)) {
            changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
            txSkeleton = txSkeleton.update("outputs", (outputs) => outputs.push(changeCell));
        }
    }
    if (amount > 0 && assertAmountEnough) {
        throw new Error("Not enough capacity in from address!");
    }
    /*
     * Modify the skeleton, so the first witness of the fromAddress script group
     * has a WitnessArgs construct with 65-byte zero filled values. While this
     * is not required, it helps in transaction fee estimation.
     */
    const firstIndex = txSkeleton
        .get("inputs")
        .findIndex((input) => new ScriptValue(input.cell_output.lock, { validate: false }).equals(new ScriptValue(fromScript, { validate: false })));
    if (firstIndex !== -1) {
        while (firstIndex >= txSkeleton.get("witnesses").size) {
            txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.push("0x"));
        }
        let witness = txSkeleton.get("witnesses").get(firstIndex);
        const newWitnessArgs = {
            /* 65-byte zeros in hex */
            lock: helper_1.SECP_SIGNATURE_PLACEHOLDER,
        };
        if (witness !== "0x") {
            const witnessArgs = new base_1.core.WitnessArgs(new ckb_js_toolkit_1.Reader(witness));
            const lock = witnessArgs.getLock();
            if (lock.hasValue() &&
                new ckb_js_toolkit_1.Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock) {
                throw new Error("Lock field in first witness is set aside for signature!");
            }
            const inputType = witnessArgs.getInputType();
            if (inputType.hasValue()) {
                newWitnessArgs.input_type = new ckb_js_toolkit_1.Reader(inputType.value().raw()).serializeJson();
            }
            const outputType = witnessArgs.getOutputType();
            if (outputType.hasValue()) {
                newWitnessArgs.output_type = new ckb_js_toolkit_1.Reader(outputType.value().raw()).serializeJson();
            }
        }
        witness = new ckb_js_toolkit_1.Reader(base_1.core.SerializeWitnessArgs(ckb_js_toolkit_1.normalizers.NormalizeWitnessArgs(newWitnessArgs))).serializeJson();
        txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.set(firstIndex, witness));
    }
    if (!assertAmountEnough) {
        return [txSkeleton, amount];
    }
    return txSkeleton;
}
exports.transfer = transfer;
/**
 * pay fee by secp256k1_blake160 script cells
 *
 * @param txSkeleton
 * @param fromAddress
 * @param amount fee in shannon
 * @param options
 */
async function payFee(txSkeleton, fromAddress, amount, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    return await transfer(txSkeleton, fromAddress, null, amount, {
        config,
        requireToAddress: false,
    });
}
exports.payFee = payFee;
/**
 * Inject capacity from `fromAddress` to target output.
 *
 * @param txSkeleton
 * @param outputIndex
 * @param fromAddress
 * @param options
 */
async function injectCapacity(txSkeleton, outputIndex, fromAddress, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    if (outputIndex >= txSkeleton.get("outputs").size) {
        throw new Error("Invalid output index!");
    }
    const capacity = BigInt(txSkeleton.get("outputs").get(outputIndex).cell_output.capacity);
    return await transfer(txSkeleton, fromAddress, null, capacity, {
        config,
        requireToAddress: false,
    });
}
exports.injectCapacity = injectCapacity;
/**
 * prepare for txSkeleton signingEntries, will update txSkeleton.get("signingEntries")
 *
 * @param txSkeleton
 * @param options
 */
function prepareSigningEntries(txSkeleton, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    return helper_1.prepareSigningEntries(txSkeleton, config, "SECP256K1_BLAKE160");
}
exports.prepareSigningEntries = prepareSigningEntries;
exports.default = {
    transfer,
    payFee,
    prepareSigningEntries,
    injectCapacity,
    setupInputCell,
    CellCollector,
};
//# sourceMappingURL=secp256k1_blake160.js.map
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.payFeeByFeeRate = exports.setupInputCell = exports.prepareSigningEntries = exports.payFee = exports.injectCapacity = exports.transfer = exports.registerCustomLockScriptInfos = void 0;
const helpers_1 = require("@ckb-lumos/helpers");
const secp256k1_blake160_multisig_1 = __importDefault(require("./secp256k1_blake160_multisig"));
const from_info_1 = require("./from_info");
const secp256k1_blake160_1 = __importDefault(require("./secp256k1_blake160"));
const config_manager_1 = require("@ckb-lumos/config-manager");
const locktime_pool_1 = __importDefault(require("./locktime_pool"));
const base_1 = require("@ckb-lumos/base");
const anyone_can_pay_1 = __importDefault(require("./anyone_can_pay"));
const { ScriptValue } = base_1.values;
const immutable_1 = require("immutable");
const core_1 = require("@ckb-lumos/base/lib/core");
const ckb_js_toolkit_1 = require("ckb-js-toolkit");
const helper_1 = require("./helper");
function defaultLogger(level, message) {
    console.log(`[${level}] ${message}`);
}
/**
 * `infos` includes predefined and customized.
 */
let lockScriptInfos = {
    configHashCode: 0,
    _predefinedInfos: [],
    _customInfos: [],
    get infos() {
        return [...this._predefinedInfos, ...this._customInfos];
    },
};
function resetLockScriptInfos() {
    lockScriptInfos.configHashCode = 0;
    lockScriptInfos._predefinedInfos = [];
    lockScriptInfos._customInfos = [];
}
function getLockScriptInfos() {
    return lockScriptInfos;
}
function registerCustomLockScriptInfos(infos) {
    lockScriptInfos._customInfos = infos;
}
exports.registerCustomLockScriptInfos = registerCustomLockScriptInfos;
function generateLockScriptInfos({ config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    // lazy load
    const getPredefinedInfos = () => {
        const secpTemplate = config.SCRIPTS.SECP256K1_BLAKE160;
        const multisigTemplate = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
        const acpTemplate = config.SCRIPTS.ANYONE_CAN_PAY;
        const predefinedInfos = [];
        if (secpTemplate) {
            predefinedInfos.push({
                code_hash: secpTemplate.CODE_HASH,
                hash_type: secpTemplate.HASH_TYPE,
                lockScriptInfo: secp256k1_blake160_1.default,
            });
        }
        else {
            defaultLogger("warn", "SECP256K1_BLAKE160 script info not found in config!");
        }
        if (multisigTemplate) {
            predefinedInfos.push({
                code_hash: multisigTemplate.CODE_HASH,
                hash_type: multisigTemplate.HASH_TYPE,
                lockScriptInfo: secp256k1_blake160_multisig_1.default,
            });
        }
        else {
            defaultLogger("warn", "SECP256K1_BLAKE160_MULTISIG script info not found in config!");
        }
        if (acpTemplate) {
            predefinedInfos.push({
                code_hash: acpTemplate.CODE_HASH,
                hash_type: acpTemplate.HASH_TYPE,
                lockScriptInfo: anyone_can_pay_1.default,
            });
        }
        else {
            defaultLogger("warn", "ANYONE_CAN_PAY script info not found in config!");
        }
        return predefinedInfos;
    };
    const configHashCode = base_1.utils.hashCode(Buffer.from(JSON.stringify(config)));
    if (lockScriptInfos.infos.length === 0) {
        lockScriptInfos._predefinedInfos = getPredefinedInfos();
        lockScriptInfos.configHashCode = configHashCode;
    }
    else {
        if (configHashCode !== lockScriptInfos.configHashCode) {
            defaultLogger(`warn`, "`config` changed, regenerate lockScriptInfos!");
            lockScriptInfos._predefinedInfos = getPredefinedInfos();
            lockScriptInfos.configHashCode = configHashCode;
        }
    }
}
/**
 *
 * @param txSkeleton
 * @param fromInfos
 * @param toAddress
 * @param changeAddress
 * @param amount
 * @param tipHeader will not use locktime cells if tipHeader not provided
 * @param options
 */
async function transfer(txSkeleton, fromInfos, toAddress, amount, changeAddress, tipHeader, { config = undefined, useLocktimeCellsFirst = true, LocktimePoolCellCollector = locktime_pool_1.default.CellCollector, } = {}) {
    config = config || config_manager_1.getConfig();
    if (!toAddress) {
        throw new Error("You must provide a to address!");
    }
    const toScript = helpers_1.parseAddress(toAddress, { config });
    const targetOutput = {
        cell_output: {
            capacity: "0x" + BigInt(amount).toString(16),
            lock: toScript,
            type: undefined,
        },
        data: "0x",
    };
    generateLockScriptInfos({ config });
    const targetLockScriptInfo = lockScriptInfos.infos.find((lockScriptInfo) => {
        return (lockScriptInfo.code_hash === toScript.code_hash &&
            lockScriptInfo.hash_type === toScript.hash_type);
    });
    if (targetLockScriptInfo &&
        "setupOutputCell" in targetLockScriptInfo.lockScriptInfo) {
        txSkeleton = await targetLockScriptInfo.lockScriptInfo.setupOutputCell(txSkeleton, targetOutput, {
            config,
        });
    }
    else {
        txSkeleton = txSkeleton.update("outputs", (outputs) => {
            return outputs.push(targetOutput);
        });
    }
    txSkeleton = await injectCapacity(txSkeleton, fromInfos, amount, changeAddress, tipHeader, {
        config,
        useLocktimeCellsFirst,
        LocktimePoolCellCollector,
    });
    return txSkeleton;
}
exports.transfer = transfer;
async function injectCapacity(txSkeleton, fromInfos, amount, changeAddress, tipHeader, { config = undefined, useLocktimeCellsFirst = true, LocktimePoolCellCollector = locktime_pool_1.default.CellCollector, } = {}) {
    config = config || config_manager_1.getConfig();
    amount = BigInt(amount);
    let deductAmount = BigInt(amount);
    if (fromInfos.length === 0) {
        throw new Error("No from info provided!");
    }
    const changeLockScript = from_info_1.parseFromInfo(changeAddress || fromInfos[0], { config }).fromScript;
    const changeCell = {
        cell_output: {
            capacity: "0x0",
            lock: changeLockScript,
            type: undefined,
        },
        data: "0x",
    };
    const minimalChangeCapacity = helpers_1.minimalCellCapacity(changeCell);
    let changeCapacity = 0n;
    if (useLocktimeCellsFirst) {
        if (tipHeader) {
            const result = await locktime_pool_1.default.injectCapacityWithoutChange(txSkeleton, fromInfos, deductAmount, tipHeader, minimalChangeCapacity, {
                config,
                LocktimeCellCollector: LocktimePoolCellCollector,
            });
            txSkeleton = result.txSkeleton;
            deductAmount = result.capacity;
            // if deductAmount > 0, changeCapacity must be 0
            changeCapacity = result.changeCapacity;
        }
        if (deductAmount > 0n) {
            const result = await _commonTransfer(txSkeleton, fromInfos, deductAmount, minimalChangeCapacity, { config });
            txSkeleton = result.txSkeleton;
            deductAmount = result.capacity;
            changeCapacity = result.changeCapacity;
        }
        else if (deductAmount === 0n &&
            changeCapacity > 0n &&
            changeCapacity < minimalChangeCapacity) {
            const result = await _commonTransfer(txSkeleton, fromInfos, minimalChangeCapacity - changeCapacity, 0n, { config });
            txSkeleton = result.txSkeleton;
            deductAmount = result.capacity;
            changeCapacity = result.changeCapacity;
        }
    }
    else {
        const result = await _commonTransfer(txSkeleton, fromInfos, deductAmount, minimalChangeCapacity, { config });
        txSkeleton = result.txSkeleton;
        deductAmount = result.capacity;
        changeCapacity = result.changeCapacity;
        if (tipHeader) {
            if (deductAmount > 0n) {
                const result = await locktime_pool_1.default.injectCapacityWithoutChange(txSkeleton, fromInfos, deductAmount, tipHeader, minimalChangeCapacity, {
                    config,
                    LocktimeCellCollector: LocktimePoolCellCollector,
                });
                txSkeleton = result.txSkeleton;
                deductAmount = result.capacity;
                changeCapacity = result.changeCapacity;
            }
            else if (deductAmount === 0n &&
                changeCapacity > 0n &&
                changeCapacity < minimalChangeCapacity) {
                const result = await locktime_pool_1.default.injectCapacityWithoutChange(txSkeleton, fromInfos, minimalChangeCapacity - changeCapacity, tipHeader, 0n, {
                    config,
                    LocktimeCellCollector: LocktimePoolCellCollector,
                });
                txSkeleton = result.txSkeleton;
                deductAmount = result.capacity;
                changeCapacity = result.changeCapacity;
            }
        }
    }
    if (deductAmount > 0n) {
        throw new Error("Not enough capacity in from infos!");
    }
    if (changeCapacity > 0n && changeCapacity < minimalChangeCapacity) {
        throw new Error("Not enough capacity in from infos for change!");
    }
    if (changeCapacity > 0n) {
        changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
        txSkeleton = txSkeleton.update("outputs", (outputs) => {
            return outputs.push(changeCell);
        });
    }
    return txSkeleton;
}
exports.injectCapacity = injectCapacity;
async function payFee(txSkeleton, fromInfos, amount, tipHeader, { config = undefined, useLocktimeCellsFirst = true, } = {}) {
    return injectCapacity(txSkeleton, fromInfos, amount, undefined, tipHeader, {
        config,
        useLocktimeCellsFirst,
    });
}
exports.payFee = payFee;
function prepareSigningEntries(txSkeleton, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    generateLockScriptInfos({ config });
    for (const lockScriptInfo of lockScriptInfos.infos) {
        txSkeleton = lockScriptInfo.lockScriptInfo.prepareSigningEntries(txSkeleton, { config });
    }
    return txSkeleton;
}
exports.prepareSigningEntries = prepareSigningEntries;
async function _commonTransfer(txSkeleton, fromInfos, amount, minimalChangeCapacity, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    amount = BigInt(amount);
    const cellProvider = txSkeleton.get("cellProvider");
    if (!cellProvider) {
        throw new Error("Cell Provider is missing!");
    }
    const getInputKey = (input) => `${input.out_point.tx_hash}_${input.out_point.index}`;
    let previousInputs = immutable_1.Set();
    for (const input of txSkeleton.get("inputs")) {
        previousInputs = previousInputs.add(getInputKey(input));
    }
    const fromScripts = fromInfos.map((fromInfo) => {
        return from_info_1.parseFromInfo(fromInfo, { config }).fromScript;
    });
    for (const fromScript of fromScripts) {
        if (amount > 0n) {
            [txSkeleton, amount] = _deductCapacity(txSkeleton, fromScript, amount);
        }
    }
    generateLockScriptInfos({ config });
    let changeCapacity = 0n;
    if (amount > 0n) {
        // collect cells
        loop1: for (const fromInfo of fromInfos) {
            const cellCollectors = lockScriptInfos.infos.map((lockScriptInfo) => {
                return new lockScriptInfo.lockScriptInfo.CellCollector(fromInfo, cellProvider, {
                    config,
                });
            });
            for (const cellCollector of cellCollectors) {
                for await (const inputCell of cellCollector.collect()) {
                    const inputKey = getInputKey(inputCell);
                    if (previousInputs.has(inputKey)) {
                        continue;
                    }
                    previousInputs = previousInputs.add(inputKey);
                    const result = await collectInput(txSkeleton, inputCell, fromInfo, {
                        config,
                        needCapacity: amount,
                    });
                    txSkeleton = result.txSkeleton;
                    const inputCapacity = BigInt(result.availableCapacity);
                    let deductCapacity = inputCapacity;
                    if (deductCapacity > amount) {
                        deductCapacity = amount;
                    }
                    amount -= deductCapacity;
                    changeCapacity += inputCapacity - deductCapacity;
                    if (amount === 0n &&
                        (changeCapacity === 0n || changeCapacity > minimalChangeCapacity)) {
                        break loop1;
                    }
                }
            }
        }
    }
    return {
        txSkeleton,
        capacity: amount,
        changeCapacity,
    };
}
function _deductCapacity(txSkeleton, fromScript, capacity) {
    /*
     * First, check if there is any output cells that contains enough capacity
     * for us to tinker with.
     *
     * TODO: the solution right now won't cover all cases, some outputs before the
     * last output might still be tinkerable, right now we are working on the
     * simple solution, later we can change this for more optimizations.
     */
    const lastFreezedOutput = txSkeleton
        .get("fixedEntries")
        .filter(({ field }) => field === "outputs")
        .maxBy(({ index }) => index);
    let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;
    for (; i < txSkeleton.get("outputs").size && capacity > 0; i++) {
        const output = txSkeleton.get("outputs").get(i);
        if (new ScriptValue(output.cell_output.lock, { validate: false }).equals(new ScriptValue(fromScript, { validate: false }))) {
            const clonedOutput = JSON.parse(JSON.stringify(output));
            const cellCapacity = BigInt(clonedOutput.cell_output.capacity);
            const availableCapacity = cellCapacity;
            let deductCapacity;
            if (capacity >= availableCapacity) {
                deductCapacity = availableCapacity;
            }
            else {
                deductCapacity = cellCapacity - helpers_1.minimalCellCapacity(clonedOutput);
                if (deductCapacity > capacity) {
                    deductCapacity = capacity;
                }
            }
            capacity -= deductCapacity;
            clonedOutput.cell_output.capacity =
                "0x" + (cellCapacity - deductCapacity).toString(16);
            txSkeleton = txSkeleton.update("outputs", (outputs) => {
                return outputs.update(i, () => clonedOutput);
            });
        }
    }
    // Remove all output cells with capacity equal to 0
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.filter((output) => BigInt(output.cell_output.capacity) !== BigInt(0));
    });
    return [txSkeleton, capacity];
}
// Alter output generated by `setupInputCell`
async function collectInput(txSkeleton, inputCell, fromInfo, { config = undefined, since = undefined, defaultWitness = "0x", needCapacity = undefined, } = {}) {
    config = config || config_manager_1.getConfig();
    txSkeleton = await setupInputCell(txSkeleton, inputCell, fromInfo, {
        config,
        since,
        defaultWitness,
    });
    const lastOutputIndex = txSkeleton.get("outputs").size - 1;
    const lastOutput = txSkeleton.get("outputs").get(lastOutputIndex);
    const lastOutputCapacity = BigInt(lastOutput.cell_output.capacity);
    const lastOutputFixedEntryIndex = txSkeleton
        .get("fixedEntries")
        .findIndex((fixedEntry) => {
        return (fixedEntry.field === "outputs" && fixedEntry.index === lastOutputIndex);
    });
    const fromScript = inputCell.cell_output.lock;
    let availableCapacity = 0n;
    if (config.SCRIPTS.ANYONE_CAN_PAY && helper_1.isAcpScript(fromScript, config)) {
        const destroyable = !!(fromInfo &&
            typeof fromInfo === "object" &&
            "destroyable" in fromInfo &&
            fromInfo.destroyable);
        needCapacity = needCapacity || lastOutputCapacity;
        if (destroyable) {
            availableCapacity = lastOutputCapacity;
            // remove output & fixedEntry added by `setupInputCell`
            txSkeleton = txSkeleton.update("outputs", (outputs) => {
                return outputs.remove(lastOutputIndex);
            });
            if (lastOutputFixedEntryIndex >= 0) {
                txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
                    return fixedEntries.remove(lastOutputFixedEntryIndex);
                });
            }
        }
        else {
            // Ignore `fixedEntries` and update capacity of output which generated by `setupInputCell`
            const minimalOutputCapacity = helpers_1.minimalCellCapacity(lastOutput);
            const canUseCapacity = lastOutputCapacity - minimalOutputCapacity;
            const clonedLastOutput = JSON.parse(JSON.stringify(lastOutput));
            let outputCapacity = minimalOutputCapacity;
            availableCapacity = canUseCapacity;
            if (needCapacity < canUseCapacity) {
                outputCapacity = lastOutputCapacity - needCapacity;
                availableCapacity = needCapacity;
            }
            clonedLastOutput.cell_output.capacity =
                "0x" + outputCapacity.toString(16);
            txSkeleton = txSkeleton.update("outputs", (outputs) => {
                return outputs.update(lastOutputIndex, () => clonedLastOutput);
            });
        }
    }
    else {
        // Ignore if last output is fixed.
        if (lastOutputFixedEntryIndex < 0) {
            // Remove last output
            availableCapacity = BigInt(txSkeleton.get("outputs").get(lastOutputIndex).cell_output.capacity);
            txSkeleton = txSkeleton.update("outputs", (outputs) => {
                return outputs.remove(lastOutputIndex);
            });
        }
    }
    return {
        txSkeleton,
        availableCapacity,
    };
}
/**
 * A function to transfer input to output, and add input & output to txSkeleton.
 * And it will deal with cell deps and witnesses too. (Add the input required cell deps and witnesses.)
 * It should be noted that the output must be added to the end of txSkeleton.get("outputs").
 *
 * @param txSkeleton
 * @param inputCell
 * @param fromInfo
 * @param options
 */
async function setupInputCell(txSkeleton, inputCell, fromInfo, { config = undefined, since = undefined, defaultWitness = undefined, } = {}) {
    config = config || config_manager_1.getConfig();
    generateLockScriptInfos({ config });
    const inputLock = inputCell.cell_output.lock;
    const targetLockScriptInfo = lockScriptInfos.infos.find((lockScriptInfo) => {
        return (lockScriptInfo.code_hash === inputLock.code_hash &&
            lockScriptInfo.hash_type === inputLock.hash_type);
    });
    if (!targetLockScriptInfo) {
        throw new Error(`No LockScriptInfo found for setupInputCell!`);
    }
    return targetLockScriptInfo.lockScriptInfo.setupInputCell(txSkeleton, inputCell, fromInfo, {
        config,
        since,
        defaultWitness,
    });
}
exports.setupInputCell = setupInputCell;
async function payFeeByFeeRate(txSkeleton, fromInfos, feeRate, tipHeader, { config = undefined, useLocktimeCellsFirst = true, } = {}) {
    feeRate = BigInt(feeRate);
    let size = 0;
    let newTxSkeleton = txSkeleton;
    /**
     * Only one case `currentTransactionSize < size` :
     * change output capacity equals current fee (feeA), so one output reduced,
     * and if reduce the fee, change output will add again, fee will increase to feeA.
     */
    let currentTransactionSize = getTransactionSize(newTxSkeleton);
    while (currentTransactionSize > size) {
        size = currentTransactionSize;
        const fee = calculateFee(size, feeRate);
        newTxSkeleton = await payFee(txSkeleton, fromInfos, fee, tipHeader, {
            config,
            useLocktimeCellsFirst,
        });
        currentTransactionSize = getTransactionSize(newTxSkeleton);
    }
    return newTxSkeleton;
}
exports.payFeeByFeeRate = payFeeByFeeRate;
function calculateFee(size, feeRate) {
    const ratio = 1000n;
    const base = BigInt(size) * feeRate;
    const fee = base / ratio;
    if (fee * ratio < base) {
        return fee + 1n;
    }
    return fee;
}
function getTransactionSize(txSkeleton) {
    const tx = helpers_1.createTransactionFromSkeleton(txSkeleton);
    return getTransactionSizeByTx(tx);
}
function getTransactionSizeByTx(tx) {
    const serializedTx = core_1.SerializeTransaction(ckb_js_toolkit_1.normalizers.NormalizeTransaction(tx));
    // 4 is serialized offset bytesize
    const size = serializedTx.byteLength + 4;
    return size;
}
exports.default = {
    transfer,
    payFee,
    prepareSigningEntries,
    injectCapacity,
    setupInputCell,
    registerCustomLockScriptInfos,
    payFeeByFeeRate,
    __tests__: {
        _commonTransfer,
        resetLockScriptInfos,
        getLockScriptInfos,
        generateLockScriptInfos,
        getTransactionSizeByTx,
        getTransactionSize,
        calculateFee,
    },
};
//# sourceMappingURL=common.js.map
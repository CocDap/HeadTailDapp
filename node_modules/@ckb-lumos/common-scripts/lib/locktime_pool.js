"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupInputCell = exports.injectCapacity = exports.prepareSigningEntries = exports.payFee = exports.transfer = exports.CellCollector = void 0;
const helpers_1 = require("@ckb-lumos/helpers");
const from_info_1 = require("./from_info");
const secp256k1_blake160_1 = __importDefault(require("./secp256k1_blake160"));
const dao_1 = require("./dao");
const base_1 = require("@ckb-lumos/base");
const { toBigUInt64LE, readBigUInt64LE } = base_1.utils;
const { ScriptValue } = base_1.values;
const ckb_js_toolkit_1 = require("ckb-js-toolkit");
const helper_1 = require("./helper");
const { parseSince, parseEpoch, maximumAbsoluteEpochSince, generateAbsoluteEpochSince, validateSince, } = base_1.since;
const immutable_1 = require("immutable");
const config_manager_1 = require("@ckb-lumos/config-manager");
const _1 = require(".");
class CellCollector {
    constructor(fromInfo, cellProvider, { config = undefined, queryOptions = {}, tipHeader = undefined, NodeRPC = ckb_js_toolkit_1.RPC, } = {}) {
        if (!cellProvider) {
            throw new Error(`Cell provider is missing!`);
        }
        config = config || config_manager_1.getConfig();
        const result = from_info_1.parseFromInfo(fromInfo, { config });
        const fromScript = result.fromScript;
        this.multisigScript = result.multisigScript;
        this.fromScript = fromScript;
        this.config = config;
        this.tipHeader = tipHeader;
        this.rpc = new NodeRPC(cellProvider.uri);
        queryOptions = {
            ...queryOptions,
            lock: this.fromScript,
        };
        let cellCollectors = immutable_1.List([]);
        if (helper_1.isSecp256k1Blake160MultisigScript(fromScript, config)) {
            const lock = {
                code_hash: fromScript.code_hash,
                hash_type: fromScript.hash_type,
                args: fromScript.args.slice(0, 42),
            };
            // multisig with locktime, not dao
            cellCollectors = cellCollectors.push(cellProvider.collector({
                lock,
                argsLen: queryOptions.argsLen || 28,
                type: queryOptions.type || "empty",
                data: queryOptions.data || "0x",
            }));
            // multisig without locktime, dao
            if (!queryOptions.type &&
                (!queryOptions.data || queryOptions.data === "any")) {
                cellCollectors = cellCollectors.push(cellProvider.collector({
                    lock,
                    type: helper_1.generateDaoScript(config),
                    data: "any",
                }));
                // multisig with locktime, dao
                cellCollectors = cellCollectors.push(cellProvider.collector({
                    lock,
                    argsLen: 28,
                    type: helper_1.generateDaoScript(config),
                    data: "any",
                }));
            }
        }
        else if (helper_1.isSecp256k1Blake160Script(fromScript, config)) {
            // secp256k1_blake160, dao
            if (!queryOptions.type &&
                (!queryOptions.data || queryOptions.data === "any")) {
                cellCollectors = cellCollectors.push(cellProvider.collector({
                    lock: fromScript,
                    type: helper_1.generateDaoScript(config),
                    data: "any",
                }));
            }
        }
        this.cellCollectors = cellCollectors;
    }
    async *collect() {
        for (const cellCollector of this.cellCollectors) {
            for await (const inputCell of cellCollector.collect()) {
                const lock = inputCell.cell_output.lock;
                let since;
                let maximumCapacity;
                let depositBlockHash;
                let withdrawBlockHash;
                let sinceBaseValue;
                // multisig
                if (lock.args.length === 58) {
                    const header = await this.rpc.get_header(inputCell.block_hash);
                    since = "0x" + _parseMultisigArgsSince(lock.args).toString(16);
                    sinceBaseValue = {
                        epoch: header.epoch,
                        number: header.number,
                        timestamp: header.timestamp,
                    };
                }
                // dao
                if (helper_1.isDaoScript(inputCell.cell_output.type, this.config)) {
                    if (inputCell.data === "0x0000000000000000") {
                        continue;
                    }
                    const transactionWithStatus = await this.rpc.get_transaction(inputCell.out_point.tx_hash);
                    withdrawBlockHash = transactionWithStatus.tx_status.block_hash;
                    const transaction = transactionWithStatus.transaction;
                    const depositOutPoint = transaction.inputs[+inputCell.out_point.index].previous_output;
                    depositBlockHash = (await this.rpc.get_transaction(depositOutPoint.tx_hash)).tx_status.block_hash;
                    const depositBlockHeader = await this.rpc.get_header(depositBlockHash);
                    const withdrawBlockHeader = await this.rpc.get_header(withdrawBlockHash);
                    let daoSince = "0x" +
                        dao_1.calculateDaoEarliestSince(depositBlockHeader.epoch, withdrawBlockHeader.epoch).toString(16);
                    maximumCapacity = dao_1.calculateMaximumWithdraw(inputCell, depositBlockHeader.dao, withdrawBlockHeader.dao);
                    const withdrawEpochValue = parseEpoch(withdrawBlockHeader.epoch);
                    const fourEpochsLater = {
                        number: withdrawEpochValue.number + 4,
                        length: withdrawEpochValue.length,
                        index: withdrawEpochValue.index,
                    };
                    daoSince = maximumAbsoluteEpochSince(daoSince, generateAbsoluteEpochSince(fourEpochsLater));
                    // if multisig with locktime
                    if (since) {
                        const multisigSince = parseSince(since);
                        if (!(multisigSince.relative === false &&
                            multisigSince.type === "epochNumber")) {
                            // throw new Error(
                            //   "Multisig since not an absolute-epoch-number since format!"
                            // );
                            // skip multisig with locktime in non-absolute-epoch-number format, can't unlock it
                            continue;
                        }
                        try {
                            since = maximumAbsoluteEpochSince(daoSince, since);
                        }
                        catch {
                            since = daoSince;
                        }
                    }
                    else {
                        since = daoSince;
                    }
                }
                if (this.tipHeader &&
                    !validateSince(since, this.tipHeader, sinceBaseValue)) {
                    continue;
                }
                const result = {
                    ...inputCell,
                    since: since,
                    depositBlockHash: depositBlockHash,
                    withdrawBlockHash: withdrawBlockHash,
                    sinceBaseValue,
                };
                result.cell_output.capacity =
                    "0x" +
                        (maximumCapacity || BigInt(inputCell.cell_output.capacity)).toString(16);
                yield result;
            }
        }
    }
}
exports.CellCollector = CellCollector;
async function transfer(txSkeleton, fromInfos, toAddress, amount, tipHeader, { config = undefined, requireToAddress = true, assertAmountEnough = true, LocktimeCellCollector = CellCollector, } = {}) {
    amount = BigInt(amount);
    for (const [index, fromInfo] of fromInfos.entries()) {
        const value = (await _transfer(txSkeleton, fromInfo, index === 0 ? toAddress : undefined, amount, tipHeader, {
            config,
            requireToAddress: index === 0 ? requireToAddress : false,
            assertAmountEnough: false,
            LocktimeCellCollector,
        }));
        // [txSkeleton, amount] = value
        txSkeleton = value[0];
        amount = value[1];
        if (amount === BigInt(0)) {
            if (assertAmountEnough) {
                return txSkeleton;
            }
            return [txSkeleton, amount];
        }
    }
    if (assertAmountEnough) {
        throw new Error("Not enough capacity in from addresses!");
    }
    return [txSkeleton, amount];
}
exports.transfer = transfer;
async function _transfer(txSkeleton, fromInfo, toAddress, amount, tipHeader, { config = undefined, requireToAddress = true, assertAmountEnough = true, LocktimeCellCollector = CellCollector, changeAddress = undefined, }) {
    config = config || config_manager_1.getConfig();
    // fromScript can be secp256k1_blake160 / secp256k1_blake160_multisig
    const { fromScript } = from_info_1.parseFromInfo(fromInfo, { config });
    // validate fromScript
    if (!helper_1.isSecp256k1Blake160MultisigScript(fromScript, config) &&
        !helper_1.isSecp256k1Blake160Script(fromScript, config)) {
        throw new Error("fromInfo not supported!");
    }
    if (requireToAddress && !toAddress) {
        throw new Error("You must provide a to address!");
    }
    amount = BigInt(amount || 0);
    if (toAddress) {
        const toScript = helpers_1.parseAddress(toAddress, { config });
        txSkeleton = txSkeleton.update("outputs", (outputs) => {
            return outputs.push({
                cell_output: {
                    capacity: "0x" + amount.toString(16),
                    lock: toScript,
                    type: undefined,
                },
                data: "0x",
                out_point: undefined,
                block_hash: undefined,
            });
        });
    }
    const lastFreezedOutput = txSkeleton
        .get("fixedEntries")
        .filter(({ field }) => field === "outputs")
        .maxBy(({ index }) => index);
    let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;
    for (; i < txSkeleton.get("outputs").size && amount > 0; ++i) {
        const output = txSkeleton.get("outputs").get(i);
        if (new ScriptValue(output.cell_output.lock, { validate: false }).equals(new ScriptValue(fromScript, { validate: false }))) {
            const cellCapacity = BigInt(output.cell_output.capacity);
            let deductCapacity;
            if (amount >= cellCapacity) {
                deductCapacity = cellCapacity;
            }
            else {
                deductCapacity = cellCapacity - helpers_1.minimalCellCapacity(output);
                if (deductCapacity > amount) {
                    deductCapacity = amount;
                }
            }
            amount -= deductCapacity;
            const clonedOutput = JSON.parse(JSON.stringify(output));
            clonedOutput.cell_output.capacity =
                "0x" + (cellCapacity - deductCapacity).toString(16);
            txSkeleton = txSkeleton.update("outputs", (outputs) => {
                return outputs.update(i, () => clonedOutput);
            });
        }
    }
    // remove all output cells with capacity equal to 0
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.filter((output) => BigInt(output.cell_output.capacity) !== BigInt(0));
    });
    /*
     * Collect and add new input cells so as to prepare remaining capacities.
     */
    if (amount > 0n) {
        const cellProvider = txSkeleton.get("cellProvider");
        if (!cellProvider) {
            throw new Error("cell provider is missing!");
        }
        const changeLockScript = changeAddress
            ? helpers_1.parseAddress(changeAddress, { config })
            : fromScript;
        const changeCell = {
            cell_output: {
                capacity: "0x0",
                lock: changeLockScript,
                type: undefined,
            },
            data: "0x",
            out_point: undefined,
            block_hash: undefined,
        };
        let changeCapacity = BigInt(0);
        let previousInputs = immutable_1.Set();
        for (const input of txSkeleton.get("inputs")) {
            previousInputs = previousInputs.add(`${input.out_point.tx_hash}_${input.out_point.index}`);
        }
        const cellCollector = new LocktimeCellCollector(fromInfo, cellProvider, {
            config,
            tipHeader,
        });
        for await (const inputCell of cellCollector.collect()) {
            // skip inputs already exists in txSkeleton.inputs
            if (previousInputs.has(`${inputCell.out_point.tx_hash}_${inputCell.out_point.index}`)) {
                continue;
            }
            let multisigSince;
            if (helper_1.isSecp256k1Blake160MultisigScript(fromScript, config)) {
                const lockArgs = inputCell.cell_output.lock.args;
                multisigSince =
                    lockArgs.length === 58
                        ? _parseMultisigArgsSince(lockArgs)
                        : undefined;
            }
            let witness = "0x";
            if (helper_1.isDaoScript(inputCell.cell_output.type, config)) {
                const template = config.SCRIPTS.DAO;
                txSkeleton = helper_1.addCellDep(txSkeleton, {
                    dep_type: template.DEP_TYPE,
                    out_point: {
                        tx_hash: template.TX_HASH,
                        index: template.INDEX,
                    },
                });
                txSkeleton = txSkeleton.update("headerDeps", (headerDeps) => {
                    return headerDeps.push(inputCell.depositBlockHash, inputCell.withdrawBlockHash);
                });
                const depositHeaderDepIndex = txSkeleton.get("headerDeps").size - 2;
                const witnessArgs = {
                    input_type: toBigUInt64LE(BigInt(depositHeaderDepIndex)),
                };
                witness = new ckb_js_toolkit_1.Reader(base_1.core.SerializeWitnessArgs(ckb_js_toolkit_1.normalizers.NormalizeWitnessArgs(witnessArgs))).serializeJson();
            }
            txSkeleton = await collectInput(txSkeleton, inputCell, helper_1.isSecp256k1Blake160MultisigScript(fromScript, config)
                ? Object.assign({}, fromInfo, { since: multisigSince })
                : fromInfo, { config, defaultWitness: witness, since: inputCell.since });
            const inputCapacity = BigInt(inputCell.cell_output.capacity);
            let deductCapacity = inputCapacity;
            if (deductCapacity > amount) {
                deductCapacity = amount;
            }
            amount -= deductCapacity;
            changeCapacity += inputCapacity - deductCapacity;
            if (helper_1.isDaoScript(inputCell.cell_output.type, config)) {
                // fix inputs / outputs / witnesses
                txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
                    return fixedEntries.push({
                        field: "inputs",
                        index: txSkeleton.get("inputs").size - 1,
                    }, {
                        field: "witnesses",
                        index: txSkeleton.get("witnesses").size - 1,
                    }, {
                        field: "headerDeps",
                        index: txSkeleton.get("headerDeps").size - 2,
                    });
                });
            }
            if (amount === BigInt(0) &&
                (changeCapacity === BigInt(0) ||
                    changeCapacity > helpers_1.minimalCellCapacity(changeCell))) {
                break;
            }
        }
        if (changeCapacity > BigInt(0)) {
            changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
            txSkeleton = txSkeleton.update("outputs", (outputs) => outputs.push(changeCell));
        }
    }
    if (!assertAmountEnough) {
        return [txSkeleton, amount];
    }
    if (amount > 0n) {
        throw new Error("Not enough capacity in from address!");
    }
    return txSkeleton;
}
async function injectCapacityWithoutChange(txSkeleton, fromInfos, amount, tipHeader, minimalChangeCapacity, { config = undefined, LocktimeCellCollector = CellCollector, }) {
    config = config || config_manager_1.getConfig();
    // fromScript can be secp256k1_blake160 / secp256k1_blake160_multisig
    amount = BigInt(amount || 0);
    for (const fromInfo of fromInfos) {
        const fromScript = from_info_1.parseFromInfo(fromInfo, { config }).fromScript;
        // validate fromScript
        if (!helper_1.isSecp256k1Blake160MultisigScript(fromScript, config) &&
            !helper_1.isSecp256k1Blake160Script(fromScript, config)) {
            // Skip if not support.
            continue;
        }
        const lastFreezedOutput = txSkeleton
            .get("fixedEntries")
            .filter(({ field }) => field === "outputs")
            .maxBy(({ index }) => index);
        let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;
        for (; i < txSkeleton.get("outputs").size && amount > 0; ++i) {
            const output = txSkeleton.get("outputs").get(i);
            if (new ScriptValue(output.cell_output.lock, { validate: false }).equals(new ScriptValue(fromScript, { validate: false }))) {
                const clonedOutput = JSON.parse(JSON.stringify(output));
                const cellCapacity = BigInt(clonedOutput.cell_output.capacity);
                let deductCapacity;
                if (amount >= cellCapacity) {
                    deductCapacity = cellCapacity;
                }
                else {
                    deductCapacity = cellCapacity - helpers_1.minimalCellCapacity(clonedOutput);
                    if (deductCapacity > amount) {
                        deductCapacity = amount;
                    }
                }
                amount -= deductCapacity;
                clonedOutput.cell_output.capacity =
                    "0x" + (cellCapacity - deductCapacity).toString(16);
                txSkeleton = txSkeleton.update("outputs", (outputs) => {
                    return outputs.update(i, () => clonedOutput);
                });
            }
        }
        // remove all output cells with capacity equal to 0
        txSkeleton = txSkeleton.update("outputs", (outputs) => {
            return outputs.filter((output) => BigInt(output.cell_output.capacity) !== BigInt(0));
        });
    }
    /*
     * Collect and add new input cells so as to prepare remaining capacities.
     */
    let changeCapacity = BigInt(0);
    if (amount > 0n) {
        const cellProvider = txSkeleton.get("cellProvider");
        if (!cellProvider) {
            throw new Error("cell provider is missing!");
        }
        const getInputKey = (input) => `${input.out_point.tx_hash}_${input.out_point.index}`;
        let previousInputs = immutable_1.Set();
        for (const input of txSkeleton.get("inputs")) {
            previousInputs = previousInputs.add(getInputKey(input));
        }
        for (const fromInfo of fromInfos) {
            const fromScript = from_info_1.parseFromInfo(fromInfo, { config }).fromScript;
            const cellCollector = new LocktimeCellCollector(fromInfo, cellProvider, {
                config,
                tipHeader,
            });
            for await (const inputCell of cellCollector.collect()) {
                // skip inputs already exists in txSkeleton.inputs
                if (previousInputs.has(getInputKey(inputCell))) {
                    continue;
                }
                let witness = "0x";
                if (helper_1.isDaoScript(inputCell.cell_output.type, config)) {
                    const template = config.SCRIPTS.DAO;
                    txSkeleton = helper_1.addCellDep(txSkeleton, {
                        dep_type: template.DEP_TYPE,
                        out_point: {
                            tx_hash: template.TX_HASH,
                            index: template.INDEX,
                        },
                    });
                    txSkeleton = txSkeleton.update("headerDeps", (headerDeps) => {
                        return headerDeps.push(inputCell.depositBlockHash, inputCell.withdrawBlockHash);
                    });
                    const depositHeaderDepIndex = txSkeleton.get("headerDeps").size - 2;
                    const witnessArgs = {
                        input_type: toBigUInt64LE(BigInt(depositHeaderDepIndex)),
                    };
                    witness = new ckb_js_toolkit_1.Reader(base_1.core.SerializeWitnessArgs(ckb_js_toolkit_1.normalizers.NormalizeWitnessArgs(witnessArgs))).serializeJson();
                }
                let multisigSince;
                if (helper_1.isSecp256k1Blake160MultisigScript(fromScript, config)) {
                    // multisig
                    const lockArgs = inputCell.cell_output.lock.args;
                    multisigSince =
                        lockArgs.length === 58
                            ? _parseMultisigArgsSince(lockArgs)
                            : undefined;
                }
                txSkeleton = await collectInput(txSkeleton, inputCell, Object.assign({}, fromInfo, { since: multisigSince }), { config, defaultWitness: witness, since: inputCell.since });
                const inputCapacity = BigInt(inputCell.cell_output.capacity);
                let deductCapacity = inputCapacity;
                if (deductCapacity > amount) {
                    deductCapacity = amount;
                }
                amount -= deductCapacity;
                changeCapacity += inputCapacity - deductCapacity;
                if (helper_1.isDaoScript(inputCell.cell_output.type, config)) {
                    // fix inputs / outputs / witnesses
                    txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
                        return fixedEntries.push({
                            field: "inputs",
                            index: txSkeleton.get("inputs").size - 1,
                        }, {
                            field: "witnesses",
                            index: txSkeleton.get("witnesses").size - 1,
                        }, {
                            field: "headerDeps",
                            index: txSkeleton.get("headerDeps").size - 2,
                        });
                    });
                }
                if (amount === BigInt(0) &&
                    (changeCapacity === BigInt(0) ||
                        changeCapacity > minimalChangeCapacity)) {
                    break;
                }
            }
        }
    }
    return {
        txSkeleton,
        capacity: amount,
        changeCapacity: changeCapacity,
    };
}
async function payFee(txSkeleton, fromInfos, amount, tipHeader, { config = undefined, LocktimeCellCollector = CellCollector, } = {}) {
    return transfer(txSkeleton, fromInfos, undefined, amount, tipHeader, {
        config,
        requireToAddress: false,
        LocktimeCellCollector,
    });
}
exports.payFee = payFee;
function prepareSigningEntries(txSkeleton, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    txSkeleton = helper_1.prepareSigningEntries(txSkeleton, config, "SECP256K1_BLAKE160");
    txSkeleton = helper_1.prepareSigningEntries(txSkeleton, config, "SECP256K1_BLAKE160_MULTISIG");
    return txSkeleton;
}
exports.prepareSigningEntries = prepareSigningEntries;
async function injectCapacity(txSkeleton, outputIndex, fromInfos, tipHeader, { config = undefined, LocktimeCellCollector = CellCollector, } = {}) {
    config = config || config_manager_1.getConfig();
    if (outputIndex >= txSkeleton.get("outputs").size) {
        throw new Error("Invalid output index!");
    }
    const capacity = BigInt(txSkeleton.get("outputs").get(outputIndex).cell_output.capacity);
    return transfer(txSkeleton, fromInfos, undefined, capacity, tipHeader, {
        config,
        requireToAddress: false,
        LocktimeCellCollector,
    });
}
exports.injectCapacity = injectCapacity;
async function collectInput(txSkeleton, inputCell, fromInfo, { config = undefined, since = undefined, defaultWitness = "0x", } = {}) {
    config = config || config_manager_1.getConfig();
    txSkeleton = await setupInputCell(txSkeleton, inputCell, fromInfo, {
        config,
        since,
        defaultWitness,
    });
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.remove(outputs.size - 1);
    });
    return txSkeleton;
}
async function setupInputCell(txSkeleton, inputCell, fromInfo, { config = undefined, since = undefined, defaultWitness = "0x", } = {}) {
    config = config || config_manager_1.getConfig();
    const inputLock = inputCell.cell_output.lock;
    if (helper_1.isSecp256k1Blake160Script(inputLock, config)) {
        return secp256k1_blake160_1.default.setupInputCell(txSkeleton, inputCell, fromInfo, {
            config,
            defaultWitness,
            since,
        });
    }
    else if (helper_1.isSecp256k1Blake160MultisigScript(inputLock, config)) {
        return _1.secp256k1Blake160Multisig.setupInputCell(txSkeleton, inputCell, fromInfo, { config, defaultWitness, since });
    }
    else {
        throw new Error(`Not supported input lock!`);
    }
}
exports.setupInputCell = setupInputCell;
function _parseMultisigArgsSince(args) {
    if (args.length !== 58) {
        throw new Error("Invalid multisig with since args!");
    }
    return readBigUInt64LE("0x" + args.slice(42));
}
exports.default = {
    CellCollector,
    transfer,
    payFee,
    prepareSigningEntries,
    injectCapacity,
    setupInputCell,
    injectCapacityWithoutChange,
};
//# sourceMappingURL=locktime_pool.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareSigningEntries = exports.injectCapacity = exports.payFee = exports.transfer = exports.setupInputCell = exports.CellCollector = exports.multisigArgs = exports.serializeMultisigScript = void 0;
const helpers_1 = require("@ckb-lumos/helpers");
const base_1 = require("@ckb-lumos/base");
const config_manager_1 = require("@ckb-lumos/config-manager");
const { ScriptValue } = base_1.values;
const ckb_js_toolkit_1 = require("ckb-js-toolkit");
const immutable_1 = require("immutable");
const helper_1 = require("./helper");
const from_info_1 = require("./from_info");
Object.defineProperty(exports, "serializeMultisigScript", { enumerable: true, get: function () { return from_info_1.serializeMultisigScript; } });
Object.defineProperty(exports, "multisigArgs", { enumerable: true, get: function () { return from_info_1.multisigArgs; } });
class CellCollector {
    constructor(fromInfo, cellProvider, { config = undefined, queryOptions = {}, } = {}) {
        if (!cellProvider) {
            throw new Error(`Cell provider is missing!`);
        }
        config = config || config_manager_1.getConfig();
        const result = from_info_1.parseFromInfo(fromInfo, { config });
        this.fromScript = result.fromScript;
        this.multisigScript = result.multisigScript;
        this.config = config;
        queryOptions = {
            ...queryOptions,
            lock: this.fromScript,
            type: queryOptions.type || "empty",
        };
        this.cellCollector = cellProvider.collector(queryOptions);
    }
    async *collect() {
        if (!helper_1.isSecp256k1Blake160MultisigScript(this.fromScript, this.config)) {
            return;
        }
        for await (const inputCell of this.cellCollector.collect()) {
            yield inputCell;
        }
    }
}
exports.CellCollector = CellCollector;
/**
 * Setup input cell infos, such as cell deps and witnesses.
 *
 * @param txSkeleton
 * @param inputCell
 * @param fromInfo
 * @param options
 */
async function setupInputCell(txSkeleton, inputCell, fromInfo, { config = undefined, defaultWitness = "0x", since = undefined, requireMultisigScript = true, } = {}) {
    config = config || config_manager_1.getConfig();
    if (requireMultisigScript && typeof fromInfo !== "object") {
        throw new Error("`fromInfo` must be MultisigScript format!");
    }
    const fromScript = inputCell.cell_output.lock;
    if (fromInfo) {
        const parsedFromScript = from_info_1.parseFromInfo(fromInfo, { config })
            .fromScript;
        if (!new ScriptValue(parsedFromScript, { validate: false }).equals(new ScriptValue(fromScript, { validate: false }))) {
            throw new Error("`fromInfo` not match to input lock!");
        }
    }
    if (!helper_1.isSecp256k1Blake160MultisigScript(fromScript, config)) {
        throw new Error(`Not SECP256K1_BLAKE160_MULTISIG input!`);
    }
    // add inputCell to txSkeleton
    txSkeleton = txSkeleton.update("inputs", (inputs) => {
        return inputs.push(inputCell);
    });
    if (since) {
        txSkeleton = txSkeleton.update("inputSinces", (inputSinces) => {
            return inputSinces.set(txSkeleton.get("inputs").size - 1, since);
        });
    }
    txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
        return witnesses.push(defaultWitness);
    });
    const outputCell = {
        cell_output: {
            capacity: inputCell.cell_output.capacity,
            lock: inputCell.cell_output.lock,
            type: inputCell.cell_output.type,
        },
        data: inputCell.data,
    };
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.push(outputCell);
    });
    const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
    if (!template) {
        throw new Error(`SECP256K1_BLAKE160_MULTISIG script not defined in config!`);
    }
    const scriptOutPoint = {
        tx_hash: template.TX_HASH,
        index: template.INDEX,
    };
    // add cell dep
    txSkeleton = helper_1.addCellDep(txSkeleton, {
        out_point: scriptOutPoint,
        dep_type: template.DEP_TYPE,
    });
    // add witness
    const firstIndex = txSkeleton
        .get("inputs")
        .findIndex((input) => new ScriptValue(input.cell_output.lock, { validate: false }).equals(new ScriptValue(fromScript, { validate: false })));
    if (firstIndex !== -1) {
        while (firstIndex >= txSkeleton.get("witnesses").size) {
            txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.push("0x"));
        }
        const firstIndexWitness = txSkeleton.get("witnesses").get(firstIndex);
        // If never prepared witness of this lock script before, should using fromInfo(MultisigScript) to update witness
        if (firstIndexWitness === "0x" && typeof fromInfo !== "object") {
            throw new Error("`fromInfo` must be MultisigScript format!");
        }
        // if using MultisigScript, check witnesses
        if (typeof fromInfo === "object") {
            const multisigScript = from_info_1.parseFromInfo(fromInfo, { config })
                .multisigScript;
            let witness = txSkeleton.get("witnesses").get(firstIndex);
            const newWitnessArgs = {
                lock: "0x" +
                    multisigScript.slice(2) +
                    helper_1.SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(fromInfo.M),
            };
            if (witness !== "0x") {
                const witnessArgs = new base_1.core.WitnessArgs(new ckb_js_toolkit_1.Reader(witness));
                const lock = witnessArgs.getLock();
                if (lock.hasValue() &&
                    new ckb_js_toolkit_1.Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock) {
                    throw new Error("Lock field in first witness is set aside for signature!");
                }
                const inputType = witnessArgs.getInputType();
                if (inputType.hasValue()) {
                    newWitnessArgs.input_type = new ckb_js_toolkit_1.Reader(inputType.value().raw()).serializeJson();
                }
                const outputType = witnessArgs.getOutputType();
                if (outputType.hasValue()) {
                    newWitnessArgs.output_type = new ckb_js_toolkit_1.Reader(outputType.value().raw()).serializeJson();
                }
            }
            witness = new ckb_js_toolkit_1.Reader(base_1.core.SerializeWitnessArgs(ckb_js_toolkit_1.normalizers.NormalizeWitnessArgs(newWitnessArgs))).serializeJson();
            txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.set(firstIndex, witness));
        }
    }
    return txSkeleton;
}
exports.setupInputCell = setupInputCell;
/**
 * transfer capacity from multisig script cells
 *
 * @param txSkeleton
 * @param fromInfo fromAddress or fromMultisigScript, if this address new to txSkeleton inputs, must use fromMultisigScript
 * @param toAddress
 * @param amount transfer CKB capacity in shannon.
 * @param options
 */
async function transfer(txSkeleton, fromInfo, toAddress, amount, { config = undefined, requireToAddress = true, assertAmountEnough = true, } = {}) {
    config = config || config_manager_1.getConfig();
    const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
    if (!template) {
        throw new Error("Provided config does not have SECP256K1_BLAKE16_MULTISIG script setup!");
    }
    const scriptOutPoint = {
        tx_hash: template.TX_HASH,
        index: template.INDEX,
    };
    txSkeleton = helper_1.addCellDep(txSkeleton, {
        out_point: scriptOutPoint,
        dep_type: template.DEP_TYPE,
    });
    const { fromScript, multisigScript } = from_info_1.parseFromInfo(fromInfo, { config });
    helper_1.ensureScript(fromScript, config, "SECP256K1_BLAKE160_MULTISIG");
    const noMultisigBefore = !txSkeleton.get("inputs").find((i) => {
        return new ScriptValue(i.cell_output.lock, { validate: false }).equals(new ScriptValue(fromScript, { validate: false }));
    });
    if (noMultisigBefore && fromInfo === "string") {
        throw new Error("MultisigScript is required for witness!");
    }
    if (requireToAddress && !toAddress) {
        throw new Error("You must provide a to address!");
    }
    amount = BigInt(amount || 0);
    if (toAddress) {
        const toScript = helpers_1.parseAddress(toAddress, { config });
        txSkeleton = txSkeleton.update("outputs", (outputs) => {
            return outputs.push({
                cell_output: {
                    capacity: "0x" + amount.toString(16),
                    lock: toScript,
                    type: undefined,
                },
                data: "0x",
                out_point: undefined,
                block_hash: undefined,
            });
        });
    }
    const lastFreezedOutput = txSkeleton
        .get("fixedEntries")
        .filter(({ field }) => field === "outputs")
        .maxBy(({ index }) => index);
    let i = lastFreezedOutput ? lastFreezedOutput.index + 1 : 0;
    for (; i < txSkeleton.get("outputs").size && amount > 0; ++i) {
        const output = txSkeleton.get("outputs").get(i);
        if (new ScriptValue(output.cell_output.lock, { validate: false }).equals(new ScriptValue(fromScript, { validate: false }))) {
            const cellCapacity = BigInt(output.cell_output.capacity);
            let deductCapacity;
            if (amount >= cellCapacity) {
                deductCapacity = cellCapacity;
            }
            else {
                deductCapacity = cellCapacity - helpers_1.minimalCellCapacity(output);
                if (deductCapacity > amount) {
                    deductCapacity = amount;
                }
            }
            amount -= deductCapacity;
            output.cell_output.capacity =
                "0x" + (cellCapacity - deductCapacity).toString(16);
        }
    }
    // remove all output cells with capacity equal to 0
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.filter((output) => BigInt(output.cell_output.capacity) !== BigInt(0));
    });
    /*
     * Collect and add new input cells so as to prepare remaining capacities.
     */
    if (amount > 0n) {
        const cellProvider = txSkeleton.get("cellProvider");
        if (!cellProvider) {
            throw new Error("cell provider is missing!");
        }
        // TODO: ignore locktime now.
        const cellCollector = cellProvider.collector({
            lock: fromScript,
        });
        const changeCell = {
            cell_output: {
                capacity: "0x0",
                lock: fromScript,
                type: undefined,
            },
            data: "0x",
            out_point: undefined,
            block_hash: undefined,
        };
        let changeCapacity = BigInt(0);
        let previousInputs = immutable_1.Set();
        for (const input of txSkeleton.get("inputs")) {
            previousInputs = previousInputs.add(`${input.out_point.tx_hash}_${input.out_point.index}`);
        }
        for await (const inputCell of cellCollector.collect()) {
            // skip inputs already exists in txSkeleton.inputs
            if (previousInputs.has(`${inputCell.out_point.tx_hash}_${inputCell.out_point.index}`)) {
                continue;
            }
            txSkeleton = txSkeleton.update("inputs", (inputs) => inputs.push(inputCell));
            txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.push("0x"));
            const inputCapacity = BigInt(inputCell.cell_output.capacity);
            let deductCapacity = inputCapacity;
            if (deductCapacity > amount) {
                deductCapacity = amount;
            }
            amount -= deductCapacity;
            changeCapacity += inputCapacity - deductCapacity;
            if (amount === BigInt(0) &&
                (changeCapacity === BigInt(0) ||
                    changeCapacity > helpers_1.minimalCellCapacity(changeCell))) {
                break;
            }
        }
        if (changeCapacity > BigInt(0)) {
            changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
            txSkeleton = txSkeleton.update("outputs", (outputs) => outputs.push(changeCell));
        }
    }
    if (amount > 0 && assertAmountEnough) {
        throw new Error("Not enough capacity in from address!");
    }
    const firstIndex = txSkeleton
        .get("inputs")
        .findIndex((input) => new ScriptValue(input.cell_output.lock, { validate: false }).equals(new ScriptValue(fromScript, { validate: false })));
    if (firstIndex !== -1) {
        while (firstIndex >= txSkeleton.get("witnesses").size) {
            txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.push("0x"));
        }
        // if using MultisigScript, check witnesses
        if (noMultisigBefore || typeof fromInfo !== "string") {
            let witness = txSkeleton.get("witnesses").get(firstIndex);
            const newWitnessArgs = {
                lock: "0x" +
                    multisigScript.slice(2) +
                    helper_1.SECP_SIGNATURE_PLACEHOLDER.slice(2).repeat(fromInfo.M),
            };
            if (witness !== "0x") {
                const witnessArgs = new base_1.core.WitnessArgs(new ckb_js_toolkit_1.Reader(witness));
                const lock = witnessArgs.getLock();
                if (lock.hasValue() &&
                    new ckb_js_toolkit_1.Reader(lock.value().raw()).serializeJson() !== newWitnessArgs.lock) {
                    throw new Error("Lock field in first witness is set aside for signature!");
                }
                const inputType = witnessArgs.getInputType();
                if (inputType.hasValue()) {
                    newWitnessArgs.input_type = new ckb_js_toolkit_1.Reader(inputType.value().raw()).serializeJson();
                }
                const outputType = witnessArgs.getOutputType();
                if (outputType.hasValue()) {
                    newWitnessArgs.output_type = new ckb_js_toolkit_1.Reader(outputType.value().raw()).serializeJson();
                }
            }
            witness = new ckb_js_toolkit_1.Reader(base_1.core.SerializeWitnessArgs(ckb_js_toolkit_1.normalizers.NormalizeWitnessArgs(newWitnessArgs))).serializeJson();
            txSkeleton = txSkeleton.update("witnesses", (witnesses) => witnesses.set(firstIndex, witness));
        }
    }
    if (!assertAmountEnough) {
        return [txSkeleton, amount];
    }
    return txSkeleton;
}
exports.transfer = transfer;
/**
 * pay fee by multisig script cells
 *
 * @param txSkeleton
 * @param fromInfo
 * @param amount fee in shannon
 * @param options
 */
async function payFee(txSkeleton, fromInfo, amount, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    return transfer(txSkeleton, fromInfo, undefined, amount, {
        config,
        requireToAddress: false,
    });
}
exports.payFee = payFee;
/**
 * Inject capacity from `fromInfo` to target output.
 *
 * @param txSkeleton
 * @param outputIndex
 * @param fromInfo
 * @param options
 */
async function injectCapacity(txSkeleton, outputIndex, fromInfo, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    if (outputIndex >= txSkeleton.get("outputs").size) {
        throw new Error("Invalid output index!");
    }
    const capacity = BigInt(txSkeleton.get("outputs").get(outputIndex).cell_output.capacity);
    return transfer(txSkeleton, fromInfo, undefined, capacity, {
        config,
        requireToAddress: false,
    });
}
exports.injectCapacity = injectCapacity;
/**
 * prepare for txSkeleton signingEntries, will update txSkeleton.get("signingEntries")
 *
 * @param txSkeleton
 * @param options
 */
function prepareSigningEntries(txSkeleton, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    return helper_1.prepareSigningEntries(txSkeleton, config, "SECP256K1_BLAKE160_MULTISIG");
}
exports.prepareSigningEntries = prepareSigningEntries;
exports.default = {
    transfer,
    payFee,
    prepareSigningEntries,
    serializeMultisigScript: from_info_1.serializeMultisigScript,
    multisigArgs: from_info_1.multisigArgs,
    injectCapacity,
    setupInputCell,
    CellCollector,
};
//# sourceMappingURL=secp256k1_blake160_multisig.js.map
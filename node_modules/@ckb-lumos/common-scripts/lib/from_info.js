"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFromInfo = exports.multisigArgs = exports.serializeMultisigScript = void 0;
const base_1 = require("@ckb-lumos/base");
const helpers_1 = require("@ckb-lumos/helpers");
const config_manager_1 = require("@ckb-lumos/config-manager");
const { CKBHasher, toBigUInt64LE } = base_1.utils;
/**
 *
 * @param params multisig script params
 * @returns serialized multisig script
 */
function serializeMultisigScript({ R, M, publicKeyHashes, }) {
    if (R < 0 || R > 255) {
        throw new Error("`R` should be less than 256!");
    }
    if (M < 0 || M > 255) {
        throw new Error("`M` should be less than 256!");
    }
    // TODO: validate publicKeyHashes
    return ("0x00" +
        ("00" + R.toString(16)).slice(-2) +
        ("00" + M.toString(16)).slice(-2) +
        ("00" + publicKeyHashes.length.toString(16)).slice(-2) +
        publicKeyHashes.map((h) => h.slice(2)).join(""));
}
exports.serializeMultisigScript = serializeMultisigScript;
/**
 *
 * @param serializedMultisigScript
 * @param since
 * @returns lock script args
 */
function multisigArgs(serializedMultisigScript, since) {
    let sinceLE = "0x";
    if (since != null) {
        sinceLE = toBigUInt64LE(BigInt(since));
    }
    return (new CKBHasher().update(serializedMultisigScript).digestHex().slice(0, 42) +
        sinceLE.slice(2));
}
exports.multisigArgs = multisigArgs;
function parseFromInfo(fromInfo, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    let fromScript;
    let multisigScript;
    let destroyable;
    let customData;
    if (typeof fromInfo === "string") {
        // fromInfo is an address
        fromScript = helpers_1.parseAddress(fromInfo, { config });
    }
    else {
        if ("R" in fromInfo) {
            const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
            if (!template) {
                throw new Error("Provided config does not have SECP256K1_BLAKE16_MULTISIG script setup!");
            }
            multisigScript = serializeMultisigScript(fromInfo);
            const fromScriptArgs = multisigArgs(multisigScript, fromInfo.since);
            fromScript = {
                code_hash: template.CODE_HASH,
                hash_type: template.HASH_TYPE,
                args: fromScriptArgs,
            };
        }
        else if ("address" in fromInfo) {
            const template = config.SCRIPTS.ANYONE_CAN_PAY;
            if (!template) {
                throw new Error("Provided config does not have ANYONE_CAN_PAY script setup!");
            }
            const address = fromInfo.address;
            fromScript = helpers_1.parseAddress(address, { config });
            destroyable = fromInfo.destroyable;
            if (fromScript.code_hash !== template.CODE_HASH ||
                fromScript.hash_type !== template.HASH_TYPE) {
                throw new Error(`fromInfo.address is not ANYONE_CAN_PAY address!`);
            }
        }
        else if ("script" in fromInfo) {
            fromScript = fromInfo.script;
            customData = fromInfo.customData;
        }
        else {
            throw new Error("Invalid fromInfo format!");
        }
    }
    return {
        fromScript,
        multisigScript,
        destroyable,
        customData,
    };
}
exports.parseFromInfo = parseFromInfo;
//# sourceMappingURL=from_info.js.map
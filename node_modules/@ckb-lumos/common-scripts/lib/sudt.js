"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ownerForSudt = exports.transfer = exports.issueToken = void 0;
const helper_1 = require("./helper");
const base_1 = require("@ckb-lumos/base");
const { toBigUInt128LE, readBigUInt128LE, computeScriptHash } = base_1.utils;
const secp256k1_blake160_multisig_1 = __importDefault(require("./secp256k1_blake160_multisig"));
const from_info_1 = require("./from_info");
const common_1 = __importDefault(require("./common"));
const helpers_1 = require("@ckb-lumos/helpers");
const immutable_1 = require("immutable");
const config_manager_1 = require("@ckb-lumos/config-manager");
const locktime_pool_1 = require("./locktime_pool");
const anyone_can_pay_1 = __importStar(require("./anyone_can_pay"));
const { ScriptValue } = base_1.values;
const secp256k1_blake160_1 = __importDefault(require("./secp256k1_blake160"));
/**
 * Issue an sUDT cell
 *
 * @param txSkeleton
 * @param fromInfo
 * @param amount
 * @param capacity
 * @param tipHeader
 * @param options
 */
async function issueToken(txSkeleton, fromInfo, amount, capacity, tipHeader, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    const template = config.SCRIPTS.SUDT;
    if (!template) {
        throw new Error("Provided config does not have SUDT script setup!");
    }
    txSkeleton = helper_1.addCellDep(txSkeleton, {
        out_point: {
            tx_hash: template.TX_HASH,
            index: template.INDEX,
        },
        dep_type: template.DEP_TYPE,
    });
    const fromScript = from_info_1.parseFromInfo(fromInfo, { config }).fromScript;
    const toScript = fromScript;
    const sudtTypeScript = {
        code_hash: template.CODE_HASH,
        hash_type: template.HASH_TYPE,
        args: computeScriptHash(fromScript),
    };
    const targetOutput = {
        cell_output: {
            capacity: "0x0",
            lock: toScript,
            type: sudtTypeScript,
        },
        data: toBigUInt128LE(amount),
        out_point: undefined,
        block_hash: undefined,
    };
    if (!capacity) {
        capacity = helpers_1.minimalCellCapacity(targetOutput);
    }
    capacity = BigInt(capacity);
    targetOutput.cell_output.capacity = "0x" + capacity.toString(16);
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.push(targetOutput);
    });
    const outputIndex = txSkeleton.get("outputs").size - 1;
    // fix entry
    txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
        return fixedEntries.push({
            field: "outputs",
            index: outputIndex,
        });
    });
    txSkeleton = await common_1.default.injectCapacity(txSkeleton, [fromInfo], BigInt(targetOutput.cell_output.capacity), undefined, tipHeader, {
        config,
    });
    return txSkeleton;
}
exports.issueToken = issueToken;
/**
 *
 * @param txSkeleton
 * @param fromInfos
 * @param sudtToken
 * @param toAddress
 * @param amount
 * @param changeAddress if not provided, will use first fromInfo
 * @param capacity
 * @param tipHeader
 * @param options
 */
async function transfer(txSkeleton, fromInfos, sudtToken, toAddress, amount, changeAddress, capacity, tipHeader, { config = undefined, LocktimePoolCellCollector = locktime_pool_1.CellCollector, } = {}) {
    config = config || config_manager_1.getConfig();
    const SUDT_SCRIPT = config.SCRIPTS.SUDT;
    if (!SUDT_SCRIPT) {
        throw new Error("Provided config does not have SUDT script setup!");
    }
    if (fromInfos.length === 0) {
        throw new Error("`fromInfos` can't be empty!");
    }
    if (!toAddress) {
        throw new Error("You must provide a to address!");
    }
    const toScript = helpers_1.parseAddress(toAddress, { config });
    const fromScripts = fromInfos.map((fromInfo) => from_info_1.parseFromInfo(fromInfo, { config }).fromScript);
    const changeOutputLockScript = changeAddress
        ? helpers_1.parseAddress(changeAddress, { config })
        : fromScripts[0];
    amount = BigInt(amount);
    if (amount <= 0n) {
        throw new Error("amount must be greater than 0");
    }
    const sudtType = _generateSudtScript(sudtToken, config);
    const cellProvider = txSkeleton.get("cellProvider");
    if (!cellProvider) {
        throw new Error("Cell provider is missing!");
    }
    // if toScript is an anyone-can-pay script
    let toAddressInputCapacity = 0n;
    let toAddressInputAmount = 0n;
    if (helper_1.isAcpScript(toScript, config)) {
        const toAddressCellCollector = new anyone_can_pay_1.CellCollector(toAddress, cellProvider, {
            config,
            queryOptions: {
                type: sudtType,
                data: "any",
            },
        });
        const toAddressInput = (await toAddressCellCollector.collect().next()).value;
        if (!toAddressInput) {
            throw new Error(`toAddress ANYONE_CAN_PAY input not found!`);
        }
        txSkeleton = txSkeleton.update("inputs", (inputs) => {
            return inputs.push(toAddressInput);
        });
        txSkeleton = txSkeleton.update("witnesses", (witnesses) => {
            return witnesses.push("0x");
        });
        toAddressInputCapacity = BigInt(toAddressInput.cell_output.capacity);
        toAddressInputAmount = readBigUInt128LE(toAddressInput.data);
    }
    const targetOutput = {
        cell_output: {
            capacity: "0x0",
            lock: toScript,
            type: sudtType,
        },
        data: toBigUInt128LE(amount),
        out_point: undefined,
        block_hash: undefined,
    };
    if (capacity) {
        capacity = BigInt(capacity);
    }
    if (helper_1.isAcpScript(toScript, config)) {
        if (!capacity) {
            capacity = 0n;
        }
        targetOutput.cell_output.capacity =
            "0x" + (toAddressInputCapacity + capacity).toString(16);
        targetOutput.data = toBigUInt128LE(toAddressInputAmount + BigInt(amount));
    }
    else {
        if (!capacity) {
            capacity = helpers_1.minimalCellCapacity(targetOutput);
        }
        targetOutput.cell_output.capacity = "0x" + capacity.toString(16);
    }
    // collect cells with which includes sUDT info
    txSkeleton = txSkeleton.update("outputs", (outputs) => {
        return outputs.push(targetOutput);
    });
    txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
        return fixedEntries.push({
            field: "outputs",
            index: txSkeleton.get("outputs").size - 1,
        });
    });
    txSkeleton = helper_1.addCellDep(txSkeleton, {
        out_point: {
            tx_hash: SUDT_SCRIPT.TX_HASH,
            index: SUDT_SCRIPT.INDEX,
        },
        dep_type: SUDT_SCRIPT.DEP_TYPE,
    });
    // collect cells
    const changeCell = {
        cell_output: {
            capacity: "0x0",
            lock: changeOutputLockScript,
            type: sudtType,
        },
        data: toBigUInt128LE(0n),
        out_point: undefined,
        block_hash: undefined,
    };
    const changeCellWithoutSudt = {
        cell_output: {
            capacity: "0x0",
            lock: changeOutputLockScript,
            type: undefined,
        },
        data: "0x",
        out_point: undefined,
        block_hash: undefined,
    };
    let changeCapacity = BigInt(0);
    let changeAmount = BigInt(0);
    let previousInputs = immutable_1.Set();
    for (const input of txSkeleton.get("inputs")) {
        previousInputs = previousInputs.add(`${input.out_point.tx_hash}_${input.out_point.index}`);
    }
    let cellCollectorInfos = immutable_1.List();
    if (tipHeader) {
        fromInfos.forEach((fromInfo, index) => {
            const locktimePoolCellCollector = new LocktimePoolCellCollector(fromInfo, cellProvider, {
                config,
                tipHeader,
                queryOptions: {
                    type: sudtType,
                    data: "any",
                },
            });
            cellCollectorInfos = cellCollectorInfos.push({
                cellCollector: locktimePoolCellCollector,
                index,
            });
        });
    }
    fromInfos.forEach((fromInfo, index) => {
        const secpCollector = new secp256k1_blake160_1.default.CellCollector(fromInfo, cellProvider, {
            config,
            queryOptions: {
                type: sudtType,
                data: "any",
            },
        });
        const multisigCollector = new secp256k1_blake160_multisig_1.default.CellCollector(fromInfo, cellProvider, {
            config,
            queryOptions: {
                type: sudtType,
                data: "any",
            },
        });
        const acpCollector = new anyone_can_pay_1.default.CellCollector(fromInfo, cellProvider, {
            config,
            queryOptions: {
                type: sudtType,
                data: "any",
            },
        });
        cellCollectorInfos = cellCollectorInfos.push({
            cellCollector: secpCollector,
            index,
        }, {
            cellCollector: multisigCollector,
            index,
        }, {
            cellCollector: acpCollector,
            index,
            isAnyoneCanPay: true,
            destroyable: from_info_1.parseFromInfo(fromInfo, { config }).destroyable,
        });
    });
    if (tipHeader) {
        fromInfos.forEach((fromInfo, index) => {
            const locktimeCellCollector = new LocktimePoolCellCollector(fromInfo, cellProvider, {
                config,
                tipHeader,
            });
            cellCollectorInfos = cellCollectorInfos.push({
                cellCollector: locktimeCellCollector,
                index,
            });
        });
    }
    fromInfos.forEach((fromInfo, index) => {
        const secpCollector = new secp256k1_blake160_1.default.CellCollector(fromInfo, cellProvider, {
            config,
        });
        const multisigCollector = new secp256k1_blake160_multisig_1.default.CellCollector(fromInfo, cellProvider, {
            config,
        });
        const acpCollector = new anyone_can_pay_1.default.CellCollector(fromInfo, cellProvider, {
            config,
        });
        cellCollectorInfos = cellCollectorInfos.push({
            cellCollector: secpCollector,
            index,
        }, {
            cellCollector: multisigCollector,
            index,
        }, {
            cellCollector: acpCollector,
            index,
            isAnyoneCanPay: true,
            destroyable: from_info_1.parseFromInfo(fromInfo, { config }).destroyable,
        });
    });
    for (const { index, cellCollector, isAnyoneCanPay, destroyable, } of cellCollectorInfos) {
        for await (const inputCell of cellCollector.collect()) {
            // skip inputs already exists in txSkeleton.inputs
            const key = `${inputCell.out_point.tx_hash}_${inputCell.out_point.index}`;
            if (previousInputs.has(key)) {
                continue;
            }
            previousInputs = previousInputs.add(key);
            const fromInfo = fromInfos[index];
            txSkeleton = await common_1.default.setupInputCell(txSkeleton, inputCell, fromInfo, {
                config,
            });
            // remove output which added by `setupInputCell`
            const lastOutputIndex = txSkeleton.get("outputs").size - 1;
            txSkeleton = txSkeleton.update("outputs", (outputs) => {
                return outputs.remove(lastOutputIndex);
            });
            // remove output fixedEntry
            const fixedEntryIndex = txSkeleton
                .get("fixedEntries")
                .findIndex((fixedEntry) => {
                return (fixedEntry.field === "outputs" &&
                    fixedEntry.index === lastOutputIndex);
            });
            if (fixedEntryIndex >= 0) {
                txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
                    return fixedEntries.remove(fixedEntryIndex);
                });
            }
            const inputCapacity = BigInt(inputCell.cell_output.capacity);
            const inputAmount = inputCell.cell_output.type
                ? readBigUInt128LE(inputCell.data)
                : 0n;
            let deductCapacity = isAnyoneCanPay && !destroyable
                ? inputCapacity - helpers_1.minimalCellCapacity(inputCell)
                : inputCapacity;
            let deductAmount = inputAmount;
            if (deductCapacity > capacity) {
                deductCapacity = capacity;
            }
            capacity -= deductCapacity;
            const currentChangeCapacity = inputCapacity - deductCapacity;
            if (!isAnyoneCanPay || (isAnyoneCanPay && destroyable)) {
                changeCapacity += currentChangeCapacity;
            }
            if (deductAmount > amount) {
                deductAmount = amount;
            }
            amount -= deductAmount;
            const currentChangeAmount = inputAmount - deductAmount;
            if (!isAnyoneCanPay || (isAnyoneCanPay && destroyable)) {
                changeAmount += currentChangeAmount;
            }
            if (isAnyoneCanPay && !destroyable) {
                const acpChangeCell = {
                    cell_output: {
                        capacity: "0x" + currentChangeCapacity.toString(16),
                        lock: inputCell.cell_output.lock,
                        type: inputCell.cell_output.type,
                    },
                    data: inputCell.cell_output.type
                        ? toBigUInt128LE(currentChangeAmount)
                        : "0x",
                };
                txSkeleton = txSkeleton.update("outputs", (outputs) => {
                    return outputs.push(acpChangeCell);
                });
                if (inputCell.cell_output.type) {
                    txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
                        return fixedEntries.push({
                            field: "outputs",
                            index: txSkeleton.get("outputs").size - 1,
                        });
                    });
                }
            }
            // changeAmount = 0n, the change output no need to include sudt type script
            if (capacity === 0n &&
                amount === 0n &&
                ((changeCapacity === 0n && changeAmount === 0n) ||
                    (changeCapacity > helpers_1.minimalCellCapacity(changeCellWithoutSudt) &&
                        changeAmount === 0n))) {
                changeCell.cell_output.type = undefined;
                changeCell.data = "0x";
                break;
            }
            if (capacity === 0n &&
                amount === 0n &&
                changeCapacity > helpers_1.minimalCellCapacity(changeCellWithoutSudt) &&
                changeAmount > 0n) {
                break;
            }
        }
    }
    // if change cell is an anyone-can-pay cell and exists in txSkeleton.get("outputs")
    let changeOutputIndex = -1;
    if (helper_1.isAcpScript(changeCell.cell_output.lock, config) &&
        (changeOutputIndex = txSkeleton.get("outputs").findIndex((output) => {
            return new ScriptValue(changeCell.cell_output.lock, {
                validate: false,
            }).equals(new ScriptValue(output.cell_output.lock, { validate: false }));
        })) !== -1) {
        txSkeleton.update("outputs", (outputs) => {
            return outputs.update(changeOutputIndex, (output) => {
                const clonedOutput = JSON.parse(JSON.stringify(output));
                clonedOutput.cell_output.capacity =
                    "0x" +
                        (BigInt(output.cell_output.capacity) + changeCapacity).toString(16);
                clonedOutput.data = toBigUInt128LE(readBigUInt128LE(output.data) + changeAmount);
                return clonedOutput;
            });
        });
    }
    else if (changeCapacity >= helpers_1.minimalCellCapacity(changeCell)) {
        changeCell.cell_output.capacity = "0x" + changeCapacity.toString(16);
        if (changeAmount > 0n) {
            changeCell.data = toBigUInt128LE(changeAmount);
        }
        txSkeleton = txSkeleton.update("outputs", (outputs) => outputs.push(changeCell));
        if (changeAmount > 0n) {
            txSkeleton = txSkeleton.update("fixedEntries", (fixedEntries) => {
                return fixedEntries.push({
                    field: "outputs",
                    index: txSkeleton.get("outputs").size - 1,
                });
            });
        }
    }
    else if (changeAmount > 0n &&
        changeCapacity < helpers_1.minimalCellCapacity(changeCell)) {
        throw new Error("Not enough capacity for change in from infos!");
    }
    if (capacity > 0) {
        throw new Error("Not enough capacity in from infos!");
    }
    if (amount > 0) {
        throw new Error("Not enough amount in from infos!");
    }
    return txSkeleton;
}
exports.transfer = transfer;
function _generateSudtScript(token, config) {
    const SUDT_SCRIPT = config.SCRIPTS.SUDT;
    // TODO: check token is a valid hash
    return {
        code_hash: SUDT_SCRIPT.CODE_HASH,
        hash_type: SUDT_SCRIPT.HASH_TYPE,
        args: token,
    };
}
/**
 * Compute sudt token by owner from info.
 *
 * @param fromInfo
 * @param options
 */
function ownerForSudt(fromInfo, { config = undefined } = {}) {
    config = config || config_manager_1.getConfig();
    const { fromScript } = from_info_1.parseFromInfo(fromInfo, { config });
    const lockHash = computeScriptHash(fromScript);
    return lockHash;
}
exports.ownerForSudt = ownerForSudt;
exports.default = {
    issueToken,
    transfer,
    ownerForSudt,
};
//# sourceMappingURL=sudt.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SECP_SIGNATURE_PLACEHOLDER = exports.ensureScript = exports.prepareSigningEntries = exports.hashWitness = exports.isAcpAddress = exports.isAcpScript = exports.isSudtScript = exports.isDaoScript = exports.isSecp256k1Blake160MultisigAddress = exports.isSecp256k1Blake160MultisigScript = exports.isSecp256k1Blake160Address = exports.isSecp256k1Blake160Script = exports.generateDaoScript = exports.addCellDep = void 0;
const immutable_1 = require("immutable");
const helpers_1 = require("@ckb-lumos/helpers");
const base_1 = require("@ckb-lumos/base");
const { CKBHasher, ckbHash } = base_1.utils;
const ckb_js_toolkit_1 = require("ckb-js-toolkit");
function addCellDep(txSkeleton, newCellDep) {
    const cellDep = txSkeleton.get("cellDeps").find((cellDep) => {
        return (cellDep.dep_type === newCellDep.dep_type &&
            new base_1.values.OutPointValue(cellDep.out_point, { validate: false }).equals(new base_1.values.OutPointValue(newCellDep.out_point, { validate: false })));
    });
    if (!cellDep) {
        txSkeleton = txSkeleton.update("cellDeps", (cellDeps) => {
            return cellDeps.push({
                out_point: newCellDep.out_point,
                dep_type: newCellDep.dep_type,
            });
        });
    }
    return txSkeleton;
}
exports.addCellDep = addCellDep;
function generateDaoScript(config) {
    const template = config.SCRIPTS.DAO;
    return {
        code_hash: template.CODE_HASH,
        hash_type: template.HASH_TYPE,
        args: "0x",
    };
}
exports.generateDaoScript = generateDaoScript;
function isSecp256k1Blake160Script(script, config) {
    const template = config.SCRIPTS.SECP256K1_BLAKE160;
    return (script.code_hash === template.CODE_HASH &&
        script.hash_type === template.HASH_TYPE);
}
exports.isSecp256k1Blake160Script = isSecp256k1Blake160Script;
function isSecp256k1Blake160Address(address, config) {
    const script = helpers_1.parseAddress(address, { config });
    return isSecp256k1Blake160Script(script, config);
}
exports.isSecp256k1Blake160Address = isSecp256k1Blake160Address;
function isSecp256k1Blake160MultisigScript(script, config) {
    const template = config.SCRIPTS.SECP256K1_BLAKE160_MULTISIG;
    return (script.code_hash === template.CODE_HASH &&
        script.hash_type === template.HASH_TYPE);
}
exports.isSecp256k1Blake160MultisigScript = isSecp256k1Blake160MultisigScript;
function isSecp256k1Blake160MultisigAddress(address, config) {
    const script = helpers_1.parseAddress(address, { config });
    return isSecp256k1Blake160MultisigScript(script, config);
}
exports.isSecp256k1Blake160MultisigAddress = isSecp256k1Blake160MultisigAddress;
function isDaoScript(script, config) {
    const template = config.SCRIPTS.DAO;
    return (!!script &&
        script.code_hash === template.CODE_HASH &&
        script.hash_type === template.HASH_TYPE);
}
exports.isDaoScript = isDaoScript;
function isSudtScript(script, config) {
    const template = config.SCRIPTS.SUDT;
    if (!template) {
        throw new Error(`SUDT script not defined in config!`);
    }
    return (!!script &&
        script.code_hash === template.CODE_HASH &&
        script.hash_type === template.HASH_TYPE);
}
exports.isSudtScript = isSudtScript;
function isAcpScript(script, config) {
    const template = config.SCRIPTS.ANYONE_CAN_PAY;
    if (!template) {
        throw new Error(`ANYONE_CAN_PAY script not defined in config!`);
    }
    return (!!script &&
        script.code_hash === template.CODE_HASH &&
        script.hash_type === template.HASH_TYPE);
}
exports.isAcpScript = isAcpScript;
function isAcpAddress(address, config) {
    const script = helpers_1.parseAddress(address, { config });
    return isAcpScript(script, config);
}
exports.isAcpAddress = isAcpAddress;
function hashWitness(hasher, witness) {
    const lengthBuffer = new ArrayBuffer(8);
    const view = new DataView(lengthBuffer);
    view.setBigUint64(0, BigInt(new ckb_js_toolkit_1.Reader(witness).length()), true);
    hasher.update(lengthBuffer);
    hasher.update(witness);
}
exports.hashWitness = hashWitness;
function prepareSigningEntries(txSkeleton, config, scriptType) {
    const template = config.SCRIPTS[scriptType];
    if (!template) {
        throw new Error(`Provided config does not have ${scriptType} script setup!`);
    }
    let processedArgs = immutable_1.Set();
    const tx = helpers_1.createTransactionFromSkeleton(txSkeleton);
    const txHash = ckbHash(base_1.core.SerializeRawTransaction(ckb_js_toolkit_1.normalizers.NormalizeRawTransaction(tx))).serializeJson();
    const inputs = txSkeleton.get("inputs");
    const witnesses = txSkeleton.get("witnesses");
    let signingEntries = txSkeleton.get("signingEntries");
    for (let i = 0; i < inputs.size; i++) {
        const input = inputs.get(i);
        if (template.CODE_HASH === input.cell_output.lock.code_hash &&
            template.HASH_TYPE === input.cell_output.lock.hash_type &&
            !processedArgs.has(input.cell_output.lock.args)) {
            processedArgs = processedArgs.add(input.cell_output.lock.args);
            const lockValue = new base_1.values.ScriptValue(input.cell_output.lock, {
                validate: false,
            });
            const hasher = new CKBHasher();
            hasher.update(txHash);
            if (i >= witnesses.size) {
                throw new Error(`The first witness in the script group starting at input index ${i} does not exist, maybe some other part has invalidly tampered the transaction?`);
            }
            hashWitness(hasher, witnesses.get(i));
            for (let j = i + 1; j < inputs.size && j < witnesses.size; j++) {
                const otherInput = inputs.get(j);
                if (lockValue.equals(new base_1.values.ScriptValue(otherInput.cell_output.lock, {
                    validate: false,
                }))) {
                    hashWitness(hasher, witnesses.get(j));
                }
            }
            for (let j = inputs.size; j < witnesses.size; j++) {
                hashWitness(hasher, witnesses.get(j));
            }
            const signingEntry = {
                type: "witness_args_lock",
                index: i,
                message: hasher.digestHex(),
            };
            signingEntries = signingEntries.push(signingEntry);
        }
    }
    txSkeleton = txSkeleton.set("signingEntries", signingEntries);
    return txSkeleton;
}
exports.prepareSigningEntries = prepareSigningEntries;
function ensureScript(script, config, scriptType) {
    const template = config.SCRIPTS[scriptType];
    if (!template) {
        throw new Error(`Provided config does not have ${scriptType} script setup!`);
    }
    if (template.CODE_HASH !== script.code_hash ||
        template.HASH_TYPE !== script.hash_type) {
        throw new Error(`Provided script is not ${scriptType} script!`);
    }
}
exports.ensureScript = ensureScript;
/* 65-byte zeros in hex */
exports.SECP_SIGNATURE_PLACEHOLDER = "0x0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
exports.default = {
    addCellDep,
    generateDaoScript,
    isSecp256k1Blake160Script,
    isSecp256k1Blake160MultisigScript,
    isDaoScript,
    isSudtScript,
    prepareSigningEntries,
    isSecp256k1Blake160Address,
    isSecp256k1Blake160MultisigAddress,
    ensureScript,
    isAcpScript,
    isAcpAddress,
};
//# sourceMappingURL=helper.js.map
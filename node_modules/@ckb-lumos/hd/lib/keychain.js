"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = __importDefault(require("crypto"));
const elliptic_1 = require("elliptic");
const bn_js_1 = __importDefault(require("bn.js"));
const key_1 = require("./key");
const ec = new elliptic_1.ec("secp256k1");
const EMPTY_BUFFER = Buffer.from("");
// BIP32 Keychain. Not a full implementation.
class Keychain {
    constructor(privateKey, chainCode) {
        this.privateKey = EMPTY_BUFFER;
        this.publicKey = EMPTY_BUFFER;
        this.chainCode = EMPTY_BUFFER;
        this.index = 0;
        this.depth = 0;
        this.identifier = EMPTY_BUFFER;
        this.fingerprint = 0;
        this.parentFingerprint = 0;
        this.privateKey = privateKey;
        this.chainCode = chainCode;
        if (!this.isNeutered()) {
            this.publicKey = key_1.privateToPublic(this.privateKey);
        }
    }
    calculateFingerprint() {
        this.identifier = this.hash160(this.publicKey);
        this.fingerprint = this.identifier.slice(0, 4).readUInt32BE(0);
    }
    static fromSeed(seed) {
        const i = crypto_1.default
            .createHmac("sha512", Buffer.from("Bitcoin seed", "utf8"))
            .update(seed)
            .digest();
        const keychain = new Keychain(i.slice(0, 32), i.slice(32));
        keychain.calculateFingerprint();
        return keychain;
    }
    // Create a child keychain with extended public key and path.
    // Children of this keychain should not have any hardened paths.
    static fromPublicKey(publicKey, chainCode, path) {
        const keychain = new Keychain(EMPTY_BUFFER, chainCode);
        keychain.publicKey = publicKey;
        keychain.calculateFingerprint();
        const pathComponents = path.split("/");
        keychain.depth = pathComponents.length - 1;
        keychain.index = parseInt(pathComponents[pathComponents.length - 1], 10);
        return keychain;
    }
    deriveChild(index, hardened) {
        let data;
        const indexBuffer = Buffer.allocUnsafe(4);
        if (hardened) {
            const pk = Buffer.concat([Buffer.alloc(1, 0), this.privateKey]);
            indexBuffer.writeUInt32BE(index + 0x80000000, 0);
            data = Buffer.concat([pk, indexBuffer]);
        }
        else {
            indexBuffer.writeUInt32BE(index, 0);
            data = Buffer.concat([this.publicKey, indexBuffer]);
        }
        const i = crypto_1.default.createHmac("sha512", this.chainCode).update(data).digest();
        const il = i.slice(0, 32);
        const ir = i.slice(32);
        let child;
        if (this.isNeutered()) {
            child = new Keychain(EMPTY_BUFFER, ir);
            child.publicKey = Keychain.publicKeyAdd(this.publicKey, il);
            child.calculateFingerprint();
        }
        else {
            const privateKey = Keychain.privateKeyAdd(this.privateKey, il);
            child = new Keychain(privateKey, ir);
            child.calculateFingerprint();
        }
        child.index = index;
        child.depth = this.depth + 1;
        child.parentFingerprint = this.fingerprint;
        return child;
    }
    derivePath(path) {
        const master = ["m", `/`, ""];
        if (master.includes(path)) {
            return this;
        }
        let bip32 = this;
        let entries = path.split("/");
        if (entries[0] === "m") {
            entries = entries.slice(1);
        }
        entries.forEach((c) => {
            const childIndex = parseInt(c, 10);
            const hardened = c.length > 1 && c[c.length - 1] === "'";
            bip32 = bip32.deriveChild(childIndex, hardened);
        });
        return bip32;
    }
    isNeutered() {
        return this.privateKey === EMPTY_BUFFER;
    }
    hash160(data) {
        const sha256 = crypto_1.default.createHash("sha256").update(data).digest();
        return crypto_1.default.createHash("ripemd160").update(sha256).digest();
    }
    static privateKeyAdd(privateKey, factor) {
        const result = new bn_js_1.default(factor);
        result.iadd(new bn_js_1.default(privateKey));
        if (result.cmp(ec.curve.n) >= 0) {
            result.isub(ec.curve.n);
        }
        return result.toArrayLike(Buffer, "be", 32);
    }
    static publicKeyAdd(publicKey, factor) {
        const x = new bn_js_1.default(publicKey.slice(1)).toRed(ec.curve.red);
        let y = x.redSqr().redIMul(x).redIAdd(ec.curve.b).redSqrt();
        if ((publicKey[0] === 0x03) !== y.isOdd()) {
            y = y.redNeg();
        }
        const point = ec.curve.g.mul(new bn_js_1.default(factor)).add({ x, y });
        return Buffer.from(point.encode(true, true));
    }
}
exports.default = Keychain;
//# sourceMappingURL=keychain.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.publicKeyToBlake160 = exports.privateToPublic = exports.recoverFromSignature = exports.signRecoverable = void 0;
const base_1 = require("@ckb-lumos/base");
const elliptic_1 = require("elliptic");
const helper_1 = require("./helper");
const ec = new elliptic_1.ec("secp256k1");
function signRecoverable(message, privateKey) {
    base_1.utils.assertHexString("message", message);
    helper_1.assertPrivateKey(privateKey);
    const key = ec.keyFromPrivate(privateKey.slice(2));
    const { r, s, recoveryParam } = key.sign(message.slice(2), {
        canonical: true,
    });
    if (recoveryParam === null) {
        throw new Error("Sign message failed!");
    }
    const fmtR = r.toString(16).padStart(64, "0");
    const fmtS = s.toString(16).padStart(64, "0");
    const fmtRecoverableParam = recoveryParam.toString(16).padStart(2, "0");
    return "0x" + fmtR + fmtS + fmtRecoverableParam;
}
exports.signRecoverable = signRecoverable;
function recoverFromSignature(message, signature) {
    base_1.utils.assertHexString("message", message);
    base_1.utils.assertHexString("signature", signature);
    const msgBuffer = Buffer.from(message.slice(2), "hex");
    const sigBuffer = Buffer.from(signature.slice(2), "hex");
    const sign = {
        r: sigBuffer.slice(0, 32),
        s: sigBuffer.slice(32, 64),
        recoveryParam: sigBuffer[64],
    };
    const point = ec.recoverPubKey(msgBuffer, sign, sign.recoveryParam);
    const publicKey = "0x" + point.encode("hex", true).toLowerCase();
    return publicKey;
}
exports.recoverFromSignature = recoverFromSignature;
function privateToPublic(privateKey) {
    let pkBuffer = privateKey;
    if (typeof privateKey === "string") {
        helper_1.assertPrivateKey(privateKey);
        pkBuffer = Buffer.from(privateKey.slice(2), "hex");
    }
    if (pkBuffer.length !== 32) {
        throw new Error("Private key must be 32 bytes!");
    }
    const publickey = ec.keyFromPrivate(pkBuffer).getPublic(true, "hex");
    if (typeof privateKey === "string") {
        return "0x" + publickey;
    }
    return Buffer.from(publickey, "hex");
}
exports.privateToPublic = privateToPublic;
function publicKeyToBlake160(publicKey) {
    helper_1.assertPublicKey(publicKey);
    const blake160 = new base_1.utils.CKBHasher()
        .update(publicKey)
        .digestHex()
        .slice(0, 42);
    return blake160;
}
exports.publicKeyToBlake160 = publicKeyToBlake160;
exports.default = {
    signRecoverable,
    recoverFromSignature,
    privateToPublic,
    publicKeyToBlake160,
};
//# sourceMappingURL=key.js.map
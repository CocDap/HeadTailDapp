"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidKeystore = exports.IncorrectPassword = exports.UnsupportedCipher = void 0;
const crypto_1 = __importDefault(require("crypto"));
const sha3_1 = require("sha3");
const uuid_1 = require("uuid");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const extended_key_1 = require("./extended_key");
class UnsupportedCipher extends Error {
    constructor() {
        super("Unsupported cipher!");
    }
}
exports.UnsupportedCipher = UnsupportedCipher;
class IncorrectPassword extends Error {
    constructor() {
        super("Incorrect password!");
    }
}
exports.IncorrectPassword = IncorrectPassword;
class InvalidKeystore extends Error {
    constructor() {
        super("Invalid keystore, please check your file integrity.");
    }
}
exports.InvalidKeystore = InvalidKeystore;
const CIPHER = "aes-128-ctr";
const CKB_CLI_ORIGIN = "ckb-cli";
// Encrypt and save master extended private key.
class Keystore {
    constructor(theCrypto, id, origin) {
        this.version = 3;
        this.crypto = theCrypto;
        this.id = id;
        this.origin = origin;
    }
    static fromJson(json) {
        try {
            const object = JSON.parse(json);
            return new Keystore(object.crypto, object.id, object.origin);
        }
        catch {
            throw new InvalidKeystore();
        }
    }
    /**
     * Load keystore file from path.
     *
     * @param path
     */
    static load(path) {
        const json = fs_1.default.readFileSync(path, "utf-8");
        return this.fromJson(json);
    }
    /**
     * Keystore file default name is `${id}.json`.
     *
     * @param dir
     * @param options If you are sure to overwrite existing keystore file, set `overwrite` to true.
     */
    save(dir, { name = this.filename(), overwrite = false, } = {}) {
        const path = path_1.default.join(dir, name);
        if (!overwrite && fs_1.default.existsSync(path)) {
            throw new Error("Keystore file already exists!");
        }
        fs_1.default.writeFileSync(path, this.toJson());
    }
    filename() {
        return this.id + ".json";
    }
    toJson() {
        return JSON.stringify(this);
    }
    isFromCkbCli() {
        return this.origin === CKB_CLI_ORIGIN;
    }
    // Create an empty keystore object that contains empty private key
    static createEmpty() {
        const salt = crypto_1.default.randomBytes(32);
        const iv = crypto_1.default.randomBytes(16);
        const kdfparams = {
            dklen: 32,
            salt: salt.toString("hex"),
            n: 2 ** 18,
            r: 8,
            p: 1,
        };
        return new Keystore({
            ciphertext: "",
            cipherparams: {
                iv: iv.toString("hex"),
            },
            cipher: CIPHER,
            kdf: "scrypt",
            kdfparams,
            mac: "",
        }, uuid_1.v4());
    }
    static create(extendedPrivateKey, password, options = {}) {
        const salt = options.salt || crypto_1.default.randomBytes(32);
        const iv = options.iv || crypto_1.default.randomBytes(16);
        const kdfparams = {
            dklen: 32,
            salt: salt.toString("hex"),
            n: 2 ** 18,
            r: 8,
            p: 1,
        };
        const derivedKey = crypto_1.default.scryptSync(password, salt, kdfparams.dklen, Keystore.scryptOptions(kdfparams));
        const cipher = crypto_1.default.createCipheriv(CIPHER, derivedKey.slice(0, 16), iv);
        if (!cipher) {
            throw new UnsupportedCipher();
        }
        const ciphertext = Buffer.concat([
            cipher.update(Buffer.from(extendedPrivateKey.serialize().slice(2), "hex")),
            cipher.final(),
        ]);
        return new Keystore({
            ciphertext: ciphertext.toString("hex"),
            cipherparams: {
                iv: iv.toString("hex"),
            },
            cipher: CIPHER,
            kdf: "scrypt",
            kdfparams,
            mac: Keystore.mac(derivedKey, ciphertext),
        }, uuid_1.v4());
    }
    // Imported from xpub with empty private key.
    isEmpty() {
        return this.crypto.ciphertext === "" && this.crypto.mac === "";
    }
    // Decrypt and return serialized extended private key.
    decrypt(password) {
        const derivedKey = this.derivedKey(password);
        const ciphertext = Buffer.from(this.crypto.ciphertext, "hex");
        if (Keystore.mac(derivedKey, ciphertext) !== this.crypto.mac) {
            throw new IncorrectPassword();
        }
        const decipher = crypto_1.default.createDecipheriv(this.crypto.cipher, derivedKey.slice(0, 16), Buffer.from(this.crypto.cipherparams.iv, "hex"));
        return ("0x" +
            Buffer.concat([decipher.update(ciphertext), decipher.final()]).toString("hex"));
    }
    extendedPrivateKey(password) {
        return extended_key_1.ExtendedPrivateKey.parse(this.decrypt(password));
    }
    checkPassword(password) {
        const derivedKey = this.derivedKey(password);
        const ciphertext = Buffer.from(this.crypto.ciphertext, "hex");
        return Keystore.mac(derivedKey, ciphertext) === this.crypto.mac;
    }
    derivedKey(password) {
        const { kdfparams } = this.crypto;
        return crypto_1.default.scryptSync(password, Buffer.from(kdfparams.salt, "hex"), kdfparams.dklen, Keystore.scryptOptions(kdfparams));
    }
    static mac(derivedKey, ciphertext) {
        return new sha3_1.Keccak(256)
            .update(Buffer.concat([derivedKey.slice(16, 32), ciphertext]))
            .digest("hex");
    }
    static scryptOptions(kdfparams) {
        return {
            N: kdfparams.n,
            r: kdfparams.r,
            p: kdfparams.p,
            maxmem: 128 * (kdfparams.n + kdfparams.p + 2) * kdfparams.r,
        };
    }
}
exports.default = Keystore;
//# sourceMappingURL=keystore.js.map
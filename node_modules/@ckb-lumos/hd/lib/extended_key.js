"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtendedPrivateKey = exports.AccountExtendedPublicKey = exports.ExtendedPublicKey = exports.AddressType = void 0;
const keychain_1 = __importDefault(require("./keychain"));
const key_1 = __importStar(require("./key"));
const base_1 = require("@ckb-lumos/base");
const helper_1 = require("./helper");
var AddressType;
(function (AddressType) {
    AddressType[AddressType["Receiving"] = 0] = "Receiving";
    AddressType[AddressType["Change"] = 1] = "Change";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
class ExtendedPublicKey {
    constructor(publicKey, chainCode) {
        helper_1.assertPublicKey(publicKey);
        helper_1.assertChainCode(chainCode);
        this.publicKey = publicKey;
        this.chainCode = chainCode;
    }
    serialize() {
        return this.publicKey + this.chainCode.slice(2);
    }
    static parse(serialized) {
        base_1.utils.assertHexString("serialized", serialized);
        return new ExtendedPublicKey(serialized.slice(0, 68), "0x" + serialized.slice(68));
    }
}
exports.ExtendedPublicKey = ExtendedPublicKey;
// Extended public key of the BIP44 path down to account level,
// which is `m/44'/309'/0'`. This key will be persisted to wallet
// and used to derive receiving/change addresses.
class AccountExtendedPublicKey extends ExtendedPublicKey {
    static parse(serialized) {
        base_1.utils.assertHexString("serialized", serialized);
        return new AccountExtendedPublicKey(serialized.slice(0, 68), "0x" + serialized.slice(68));
    }
    publicKeyInfo(type, index) {
        const publicKey = this.getPublicKey(type, index);
        const blake160 = key_1.default.publicKeyToBlake160(publicKey);
        return {
            publicKey,
            blake160,
            path: AccountExtendedPublicKey.pathFor(type, index),
        };
    }
    static pathForReceiving(index) {
        return AccountExtendedPublicKey.pathFor(AddressType.Receiving, index);
    }
    static pathForChange(index) {
        return AccountExtendedPublicKey.pathFor(AddressType.Change, index);
    }
    static pathFor(type, index) {
        return `${AccountExtendedPublicKey.ckbAccountPath}/${type}/${index}`;
    }
    getPublicKey(type = AddressType.Receiving, index) {
        const keychain = keychain_1.default.fromPublicKey(Buffer.from(this.publicKey.slice(2), "hex"), Buffer.from(this.chainCode.slice(2), "hex"), AccountExtendedPublicKey.ckbAccountPath)
            .deriveChild(type, false)
            .deriveChild(index, false);
        return "0x" + keychain.publicKey.toString("hex");
    }
}
exports.AccountExtendedPublicKey = AccountExtendedPublicKey;
AccountExtendedPublicKey.ckbAccountPath = `m/44'/309'/0'`;
class ExtendedPrivateKey {
    constructor(privateKey, chainCode) {
        helper_1.assertPrivateKey(privateKey);
        helper_1.assertChainCode(chainCode);
        this.privateKey = privateKey;
        this.chainCode = chainCode;
    }
    serialize() {
        return this.privateKey + this.chainCode.slice(2);
    }
    toExtendedPublicKey() {
        const publicKey = key_1.privateToPublic(this.privateKey);
        return new ExtendedPublicKey(publicKey, this.chainCode);
    }
    toAccountExtendedPublicKey() {
        const masterKeychain = new keychain_1.default(Buffer.from(this.privateKey.slice(2), "hex"), Buffer.from(this.chainCode.slice(2), "hex"));
        const accountKeychain = masterKeychain.derivePath(AccountExtendedPublicKey.ckbAccountPath);
        return new AccountExtendedPublicKey("0x" + accountKeychain.publicKey.toString("hex"), "0x" + accountKeychain.chainCode.toString("hex"));
    }
    static fromSeed(seed) {
        const keychain = keychain_1.default.fromSeed(seed);
        return new ExtendedPrivateKey("0x" + keychain.privateKey.toString("hex"), "0x" + keychain.chainCode.toString("hex"));
    }
    privateKeyInfo(type, index) {
        const path = AccountExtendedPublicKey.pathFor(type, index);
        return this.privateKeyInfoByPath(path);
    }
    privateKeyInfoByPath(path) {
        const keychain = new keychain_1.default(Buffer.from(this.privateKey.slice(2), "hex"), Buffer.from(this.chainCode.slice(2), "hex")).derivePath(path);
        return this.privateKeyInfoFromKeychain(keychain, path);
    }
    privateKeyInfoFromKeychain(keychain, path) {
        return {
            privateKey: "0x" + keychain.privateKey.toString("hex"),
            publicKey: "0x" + keychain.publicKey.toString("hex"),
            path: path,
        };
    }
    static parse(serialized) {
        base_1.utils.assertHexString("serialized", serialized);
        return new ExtendedPrivateKey(serialized.slice(0, 66), "0x" + serialized.slice(66));
    }
}
exports.ExtendedPrivateKey = ExtendedPrivateKey;
//# sourceMappingURL=extended_key.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PolyjuiceWallet = void 0;
const ethers_1 = require("ethers");
const properties_1 = require("@ethersproject/properties");
const address_1 = require("@ethersproject/address");
const base_1 = require("@polyjuice-provider/base");
const logger_1 = require("@ethersproject/logger");
const bytes_1 = require("@ethersproject/bytes");
const logger = new logger_1.Logger("Polyjuice-Wallet/0.0.1");
class PolyjuiceWallet extends ethers_1.Wallet {
    constructor(privateKey, polyjuiceConfig, provider) {
        super(privateKey, provider);
        const godwokerOption = {
            godwoken: {
                rollup_type_hash: polyjuiceConfig.rollupTypeHash,
                eth_account_lock: {
                    code_hash: polyjuiceConfig.ethAccountLockCodeHash,
                    hash_type: "type",
                },
            },
        };
        if (!polyjuiceConfig.web3Url)
            throw new Error("should provide web3 rpc url in polyjuiceConfigs.");
        this.godwoker = new base_1.Godwoker(polyjuiceConfig.web3Url, godwokerOption);
        this.abi = new base_1.Abi(polyjuiceConfig.abiItems || []);
    }
    setAbi(abiItems) {
        this.abi = new base_1.Abi(abiItems);
    }
    signTransaction(transaction) {
        return properties_1.resolveProperties(transaction).then(async (tx) => {
            if (tx.from != null) {
                if (address_1.getAddress(tx.from) !== this.address) {
                    logger.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
                    throw new Error(`transaction from address mismatch, wallet address: ${this.address}, transaction address: ${transaction.from}`);
                }
                // delete tx.from;
            }
            // use godwoken-polyjuice's transaction signing method
            // (which is deifferent tx type and use a message signing)
            // to sign transaction.
            let data_with_short_address;
            try {
                data_with_short_address =
                    await this.abi.refactor_data_with_short_address(bytes_1.hexlify(tx.data || "0x00"), this.godwoker.getShortAddressByAllTypeEthAddress.bind(this.godwoker));
            }
            catch (error) {
                logger.throwArgumentError("can not replace data with short_address", "data", transaction.data);
                throw new Error(`can not replace data with short_address ${transaction.data}`);
            }
            const t = {
                from: tx.from,
                to: base_1.formalizeEthToAddress(tx.to),
                value: bytes_1.hexlify(tx.value || 0),
                data: data_with_short_address,
                gas: bytes_1.hexlify(tx.gasLimit || base_1.POLY_MAX_TRANSACTION_GAS_LIMIT),
                gasPrice: bytes_1.hexlify(tx.gasPrice || base_1.POLY_MIN_GAS_PRICE),
            };
            const polyjuice_tx = await this.godwoker.assembleRawL2Transaction(t);
            const message = await this.godwoker.generateMessageFromEthTransaction(t);
            const _signature = await bytes_1.joinSignature(this._signingKey().signDigest(message));
            const signature = this.godwoker.packSignature(_signature);
            const l2_tx = { raw: polyjuice_tx, signature: signature };
            return this.godwoker.serializeL2Transaction(l2_tx);
        });
    }
}
exports.PolyjuiceWallet = PolyjuiceWallet;
//# sourceMappingURL=wallet-signer.js.map